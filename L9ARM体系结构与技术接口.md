

 



# ARM体系结构与接口技术

## D1 计算机硬件基础

### ARM体系结构与接口

ARM体系结构(ARM)

> 存储模型
>
> 工作模式
>
> 寄存器
>
> 异常机制
>
> 流水线
>
> 指令集(汇编语言)
>
> ...,...

接口技术(驱动)

> GPIO  ==LED
>
> PWM  ==蜂鸣器
>
> UART  ==串口
>
> ADC  ==测电压
>
> RTC
>
> IIC   ==censer
>
> ...,...



### 计算机基础知识

> 输入设备
>
> 输出设备
>
> 运算器
>
> 控制器
>
> 存储器
>
> ![image-20210728180404257](F:/Typora/image-20210728180404257.png)

总线:

> 概念:是计算机中各个部件间传送信息的公共通信干线,(物理上就是导线)
>
> 分类:
>
> > 数据总线
> >
> > 地址总线
> >
> > 控制总线
>
> DMA总线 :不经过CPU直接在存储器之间进行数据传递
>
> (直接寄存器访问 direct memory access)
>
> ![image-20210728180323260](F:/Typora/image-20210728180323260.png)

### 多级存储结构与地址空间

三级存储结构		(目的:兼顾 速度 价格 容量)

> cache		 (高速缓存)
>
> 主存储器	(内存)
>
> 辅助存储器(硬盘)

地址空间

能读的空间受地址总线数量的限制

 2^n^    2根地址总线能访问的地址空间总量为4

​		 32根地址总线能访问的地址空间总量为2^32^ 即4GB

### CPU原理概述

一条指令的执行分三步

> > 取指令  (执行完一次循环, 指令计数器计数+1, 执行下一条)  
> >
> > 翻译指令码
> >
> > 运算器执行
>
>   1.取址：
>
>  CPU将PC寄存器中的地址发送给内存，内存将其地址中对应的指令返回
>
>  到CPU中的指令寄存器（IR）
>
>   2.译码：
>
>  译码器对IR中的指令进行识别，将指令（机器码）解析成具体的运算
>
>   3.执行：
>
>  控制器控制运算器中对应的运算单元进行运算，运算结果写入寄存器
>
> ![image-20210728180427741](F:/Typora/image-20210728180427741.png)



## D2 ARM体系结构理论基础

### ARM处理器概论

爱康 精简指令集 处理器(ARM)

ARM 是 (公司名称 处理器通称 一种技术)

ARM 7,9,11

cortex系列  A高端   R强调及时性   M低端    三个系列

![image-20210729092917127](F:/Typora/image-20210729092917127.png)



![image-20210729093239489](F:/Typora/image-20210729093239489.png)

SOC (system on chip )集成芯片系统

![image-20210729094324740](F:/Typora/image-20210729094324740.png)



![image-20210812160743482](F:/Typora/image-20210812160743482.png)





![image-20210812160417664](F:/Typora/image-20210812160417664.png)



![image-20210812160500229](F:/Typora/image-20210812160500229.png)



### ARM指令集概述

指令:能够指示==处理器执行==某种运算的命令称为指令(加减乘除...)

​		指令在内存中以机器码(二进制)的方式存在,每一条指令都对应一条汇编指令,

​		程序是指令的有序集合.

指令集:处理器能识别的指令的集合称为指令集,不同架构的处理器指令集不同

​			(指令集是处理器对开发者提供的接口)



ARM处理器大多数支持两种指令集

> ARM指令集:指令占32bit (4字节)(PC值每次自增4)
>
> Thumb指令集:指令占16bit(2字节)(PC值每次自增2)

编译原理

> ![image-20210729103510967](F:/Typora/image-20210729103510967.png)



### ARM存储模型

ARM采用32位架构,基本数据类型有三种

> Byte			8bit
>
> Halfword	 16bit
>
> Word		   32bit

数据存储

> word型数据在内存的起始地址必须是4的整数倍
>
> Halfword型数据在内存的起始地址必须是2的整数倍

大端对其

低地址存放高位

高地址存放低位



小端对其

低地址存放低位

高地址存放高位



> c语言变量分类及存储位置
>
> auto	栈	内存里
>
> extern  外部存储	内存里
>
> static  静态区	内存里
>
> register	返回速度很快 	放在寄存器里	不能进行取地址操作,只能是整形的,不能				是浮点型的,ARM不支持.



![image-20210729110106080](F:/Typora/image-20210729110106080.png)

Ubantu也是小端对其

![image-20210729111035856](F:/Typora/image-20210729111035856.png)

ARM状态时, 指令在 内存的起始地址 二进制机器码最后两位强制性置零

Thumb状态时,指令在 内存的起始地址 二进制机器码最后一位强制置零



### ARM工作模式

八个基本工作模式

![image-20210729114024628](F:/Typora/image-20210729114024628.png)

> user 用户模式:	执行上层应用的模式
>
> 快速中断模式:	优先级高中断
>
> 普通中断模式:	优先级低中断
>
> 超级用户模式:	刚给板子上电的时候,复位的时候,初始化的时候,软中断的时候,
>
> 终止模式
>
> 指令未定义模式
>
> 系统模式
>
> 监控模式



不同模式拥有不同权限

不同模式执行不同代码

不同模式完成不同功能



按权限分类

   User模式为非特全模式(特权较低),其余模式均为特权模式

按状态分类

​	FIQ	IRQ	SVC		Abort	Undef 属于异常模式,即当处理器遇到异常后会进入对	应的模式

## D3  ARM寄存器组织

寄存器

> 概念: 寄存器是处理器内部的存储器,
>
> 数量:ARM crotex-A9  一共有40个寄存器
>
> 特点:没有地址
>
> 作用:
>
> 一般用于暂时存放参与运算的数据和运算结果
>
> 分类:
>
> > 通用寄存器
> >
> > 专用寄存器  
> >
> > 控制寄存器



### ARM通用寄存器: 

没有额外限制,通用的寄存器

(所有带三角标的寄存器都是某个模式独占,不带三角标的,是多模式共享的)

下图所示,一共有40个寄存器.

![image-20210729164531273](F:/Typora/image-20210729164531273.png)

### ARM专用寄存器

R15: (PC) 程序计数器:用于存储当前取值指令的地址

R14:(LR: link register):链接寄存器

​			作用1:执行跳转指令(BL/BLX)时,LR会自动保存跳转指令下一条指令的地址,程序			需要返回时将LR的值复制					  到PC即可实现	(主动地情况)

​			作用2:产生异常时,对异常模式下的LR会自动保存被异常打断的指令的下一条指			令的地址,异常处理结束后			将LR的值复制到PC可实现程序返回	(被动的			情况)

R13:(SP:stack pointer)栈指针,用于存储当前模式下的栈顶地址

### ARM控制寄存器:

CPSR(32bit)

![image-20210729195849682](F:/Typora/image-20210729195849682.png)



![image-20210729200247395](F:/Typora/image-20210729200247395.png)



![image-20210729200403194](F:/Typora/image-20210729200403194.png)

​	当前程序状态寄存器CPSR。CPSR中包含条件码标志、中断禁止位、当前处理器模式以及其他状态和控制信息。在每种异常模式下都有一个对用的程序状态寄存器SPSR。当异常出现时，SPSR用于保存CPSR的状态，以便异常返回后恢复异常发生时的工作状态。

(1)条件码标志

> N、Z、C、V，最高4位称为条件码标志。ARM的大多数指令可以条件执行的，即通过检测这些条件码标志来决定程序指令如何执行。
>
> 各个条件码的含义如下：
>
> N：在结果是有符号的二进制补码情况下，如果结果为负数，则N=1；如果结果为非负数，则N=0。
>
> Z：如果结果为0，则Z=1;如果结果为非零，则Z=0。
>
> C：其设置分一下几种情况：
>
> ​        对于加法指令（包含比较指令CMN），如果产生进位，则C=1;否则C=0。
>
> ​        对于减法指令（包括比较指令CMP），如果产生借位，则C=0;否则C=1。
>
> ​        对于有移位操作的非法指令，C为移位操作中最后移出位的值。
>
> ​        对于其他指令，C通常不变。
>
> V：对于加减法指令，在操作数和结果是有符号的整数时，如果发生溢出，则V=1;如果无溢出发生，则V=0;对于其他指令，V通常不发生变化。

(2)控制位的作用在图1中可以看出

![image-20210730100233919](F:/Typora/image-20210730100233919.png)



## D4 ARM异常处理

### 异常:

概念:处理器在正常执行程序的过程中可能会遇到一些不正常的事情发生,这时处理		器就要将当前程序暂停下来转而去处理这个异常的事件,异常事件处理完了之后,再		返	回被异常打断的点继续执行程序.

### 异常处理机制:

不同的处理器对异常的处理流程大体相似,但是不同的处理器在具体的实现的机制上有所不同,比如处理器遇到哪些事件认为是异常事件,遇到异常事件之后,	处理器有哪些动作,处理器如何跳转到异常处理程序,处理完异常之后又如何返回到被打断的程序继续执行等,  这一套流程被称为异常处理机制

### ARM异常源:

导致异常产生的源头.

> ​		一共分为七类:
>
> 1. ​		FIQ	快速中断请求
> 2. ​		IRQ	外部中断请求
> 3. ​		Reset	复位 (硬中断)
> 4. ​		Software Interrupt	执行swi指令  (软中断)
> 5. ​		Data Abort	数据终止	
> 6. ​		Prefetch Abort	指令预取终止
> 7. ​		Undefined Instruction	遇到不能处理的指令

八个工作模式中有五个异常模式  (异常3. 4共用模式SVC  异常5.6共用模式Abort)

![image-20210730103418579](F:/Typora/image-20210730103418579.png)

### ARM产生异常后的动作:

1.拷贝CPSR中的内容到==对应异常模式==下的SPSR_<mode>

2.修改CPSR的值

> ​		1.修改中断禁止位禁止相应的中断
>
> ​		2.修改模式位进入相应的异常模式
>
> ​		3.修改状态位进入ARM状态(区分于Thrumb 状态, 一般都已经在ARM 状态)

3.保存返回地址到对应异常模式下的LR_<mode>

4.设置PC为相应的异常向量(异常向量表对应的地址)  (1~3 都没跳转到职场处理,4 才跳	转)

​		==异常向量表==(32byte)

![image-20210730112945100](F:/Typora/image-20210730112945100.png)

5.CPU执行处理异常的代码

6.异常返回:

​		1.将SPSR_<mode>的值复制给CPSR,使处理器恢复之前的状态

​		2.将LR_<mode>的值复制给PC,使程序跳转回被打断的地址继续执行

![image-20210730113844154](F:/Typora/image-20210730113844154.png)

### 异常优先级

1. Reset
2. Data Abort
3. FIQ  硬件
4. IRQ  硬件
5. Prefetch Abort
6. Software Interrupt
7. Undefined instruction

### FIQ and IRQ

FIQ的响应速度比IRQ快

1. FIQ在异常向量表位于最末

​    可直接把异常处理写在异常向量表之后，省去跳转

2. FIQ模式有5个私有寄存器(R8-R12)

  执行中断处理程序前无需压栈保存寄存器，可直接处理中断

3. FIQ的优先级高于IRQ

     3.1 两个中断同时发生时先响应FIQ

     3.2 FIQ可以打断RIQ，但IR1Q不能打断FIQ

### ARM微架构

指令流水线

> 1. 取址:
>
> 2. 编译
>
> 3. 执行

ARM指令流水线

> ​	ARM7采用3级流水线
>
> ​	ARM9采用5级流水线
>
> ​	Crotex-A9采用8级流水线

特点

1. 虽然流水线级数随着更新越来越多,但都是在三级流水线的基础上进行了细分

2. 不管几级流水线, PC指向的永远都是当前正在取值的指令,而当前正在执行的指令的地址为==PC-8==

3. n指令流水线机制的引入确实能够大大的提升指令执行的速度

   但在实际执行程序的过程中很多情况下流水线时是无法形成的

   比如芯片刚上电的前两个周期、执行跳转指令后的两个周期等

   所以指令流水线的引入以及优化只能使平均指令周期不断的接

   近1而不可能真正的达到1，且流水线级数越多芯片设计的复杂

   程度就越高，芯片的功耗就越高

![image-20210730135607380](F:/Typora/image-20210730135607380.png)

### 多核处理器

概念:	一个SOC中集成多个CPU核

作用:	不同的线程可以运行在不同的核心中,做到真正的并发

资源:	多核处理器公用外设与资源接口



## D5 ARM指令集仿真环境搭建

### 指令集导学

指令: 指示处理器执行某种运算的命令称为指令,指令在内存中以机器码的方式存在,每一		 条指令都对应一条汇编,程序是指令的有序集合

指令集: 处理器能识别的指令的集合称为指令集,不同架构的处理器指令集不同,指令集是		 处理器对开发者提供的接口

汇编语言: 

1.  每条汇编都会对应唯一对应的一条机器码,且CPU能直接识别和执行

2.  汇编中寄存器的使用,栈的分配与使用,程序的调动,参数的传递等都需要自己维护

C语言:

1.  每条C语句都要被编译器编译成若干条汇编指令才能被CPU识别和执行, 即C语句中的指令CPU不一定能直接识别,需要编译器进行"翻译"
2. C中寄存器的使用, 栈的分配与使用, 程序的调用,参数的传递等都是编译器分配和维护的

==理解CPU 汇编 C语言之间的相互关系==



### Keil仿真环境搭建

硬件仿真

软件仿真:  Keil

Keil  MDK 是基于ARM Cortex-M微控制器的完整开发环境



### ARM指令集概述

@汇编中的符号
@	1.指令:能够编译生成一条32位的机器码,并且能被CPU识别和执行
@	2.伪指令:本身不是指令,编译器可以将其替换成一条或多条指令
@	3.伪操作:不会生成指令,只会在编译阶段告诉编译器怎么编译

#### ARM指令集:共六种

@	1.数据处理指令:进行数学运算,逻辑运算(与或非等)
@	2.跳转指令:实现程序的跳转,修改了PC寄存器里的值
@	3.load/store指令:访问(读写)内存
@	4.状态寄存器传送指令:用于访问(读写)CPSR寄存器
@	5.软中断指令:给CPU发送中断信号,触发软中断
@	6.协处理器指令:操作协处理器的指令(浮点型运算,管理内存,非必须)

## D6数据处理指令

CPSR

NZCV 负数 	零 	进位 	溢出

IFTM  	1. IRQ	2. FIQ	3. ARM/thumb	4. 工作模式

==数据处理指令默认情况下是不会影响NZCV的==

在指令后面加'l'(跳转后加)  's'(加减后面加) 等可以改变NZCV的值

```
.text    			@当前为代码段
.global _start 		@将start定义成全局符号
_start: 			@汇编的入口

@	MOV R1,#15		@R1=1
@	MOV R2,#16
@	MOV R3,#17
@	MOV R4,#221
@	MOV R5,#128
@	MOV PC,#7
@	MOV R2=R1

@	MVN R0,#0xFF 
@	MOV R0,#0xFFFFFF00
	
@	MOV R0,#0
@	MVN R0,#0
	
@	mov r0,#0
@	mov r1,#0
	
@	mov r1,#1
@	mov r1,#2
	
@	mov R0,#0x12	
	@mov后面的数大小有限,能放到mov后面的数叫立即数(0~255,和一些其他离散数)
	@立即数的本质就是包含在指令当中的数,属于指令的一部分
	@立即数的优点: 取指令的时候就可以将其取到CPU,不用再去内存读取,速度快
	@立即数的缺点: 不能是任意的32位数字,大小也有限制
	
@	MOV R0,#0xFFFFFFFF		@gcc替换成 mvn R0,#0x00000000  所以编译时不报错
	

	@加法指令

@	mov r2,#5
@	mov r3,#3
@	add r1,r2,r3	@ r1=r2+r3
@	add r1,r2,#5	
	@两个数相加不行, 数加R 也不行, 有格式限制
	@操作码+目标寄存+第一操作寄存器+第二操作数(可以是寄存器或立即数) 
	

	@减法指令 SUB

@	sub R1,R2,R3  @ r1=r2-r3		@只能寄存器-一个数,或者寄存器-寄存器
	

	@逆向减法指令

@	rsb R2,R2,#3	@ R1=3-R2
	

	@乘法指令

@	MUL R1,R2,R3	@ R1=R2*R3		@乘法指令只能是两个寄存器相乘

	@按位与

@	AND r1,r2,r3	@ r1=r2 & r3
	

	@按位或

@	ORR r1,r2,r3	@ r1=r2 | r3
	

	@按位异或

@	EOR R1,R2,R3	@ R1=R2 ^ R3 	相同为0 相异为1
	

	@左移

@	lsl r1,r2,r3	@ r1=(r2<<r3)	R2 左移 R3 位
	

	@右移

@	LSR r1,r2,r3	@ r1=(r2>>r3)
	

	@位清零

@	MOV R2,#0xff
@	BIC r1,r2,#0x0F 	@ 把r2后四位清零后,结果给到r1,  r2不受影响
	

	@数据运算指令的格式扩展
	mov r1,r2,lsl #1    @ r2左移一位,结果给到r1
	
	@数据运算指令对条件位(NZCV)的影响

@	mov R1,#3
@	subs R2,R1,#5
	@默认情况下,数据运算不会对条件位产生影响,当在指令后加后缀"s"可以影响
	

	@两个64位的数据做加法运算(带进位的加法指令)
	@第一个数的低32位放在R1
	@第一个数的高32位放在R2
	@第二个数的低32位放在R3
	@第二个数的高32位放在R4
	@运算结果的低32位放在R5
	@运算结果的高32位放在R6
	
	@	第一个数
	@ 0x00000012 FFFFFFFF
	@ 	第二个数
	@ 0x00000022 00000021

@	MOV R1, #0xFFFFFFFF
@	MOV R2, #0x00000012
@	MOV R3, #0x00000021
@	MOV R4, #0x00000022
	
@	ADDs R5,R1,R3
@	ADc  R6,R2,R4	@ R6=R2+R4+'C'
	

	@带借位的减法指令
	@	第一个数
	@ 0x00000002 00000001
	@ 	第二个数
	@ 0x00000001 00000005
	
	MOV R1, #0x00000001
	MOV R2, #0x00000002
	MOV R3, #0x00000005
	MOV R4, #0x00000001
	
	SUBS R5,R1,R3
	SBC	 R6,R2,R4 	@ R6=R2-R4-'C'


stop:				@死循环,防止程序跑炸
	B stop

.end 	 			@汇编的结束

@代码效率相关
int a;
float a;
long long a;
a=a/2;
```



## D7跳转与存储器访问指令

### 跳转指令

```
@跳转指令:实现程序的跳转,本质就是修改了PC寄存器
	@方式一: 直接去修改PC寄存器的值(不建议直接使?需要人为计算绝对地址,可行性较差)
	
	
@main:
@	mov r1,#1 	
@	mov r2,#1
@	mov r3,#1
@	mov PC,#0x2c  (z)
@	mov r4,#1
@	mov r5,#1
	
@func:	
@	mov r6,#1
@	mov r7,#1
@	mov r8,#1
	

	@方式二: 通过不带返回的跳转指令, 本质上也是就该PC,自动的寻址指令

@main:
@	mov r1,#1	
@	mov r2,#1
@	mov r3,#1
@	b func
@	mov r4,#1
@	mov r5,#1
	
@func:	
@	mov r6,#1
@	mov r7,#1
@	mov r8,#1
	
@	方式三:带返回的跳转指令,程序跳转后, R14(LR寄存器)存储跳转前的下一条指令地址
@main:
@	mov r1,#1	
@	mov r2,#1
@	mov r3,#1
@	bl func
@	mov r4,#1
@	mov r5,#1
	
@func:	
@	mov r6,#1
@	mov r7,#1
@	mov r8,#1
@	mov PC,LR
```



### ARM指令的条件码

![image-20210802112319361](F:/Typora/image-20210802112319361.png)



![image-20210802112401136](F:/Typora/image-20210802112401136.png)

条件码: 就是指令的后缀

### 内存访问指令

```
load/store 指令:访问(读写)内存

指令 LD(加载,load)  ST(存储store)

	@load/store 指令: 访问(读写)内存
	@写内存

@	mov r1,#0xFF000000
@	mov r2,#0x40000000
@	str r1,[r2]		@将R1寄存器中的数据存储到R2指向的内存空间
	

	@读内存

@	ldr r3,[r2]		@将寄存器r2指向的内存空间中的数据读取到r3寄存器

	mov r1,#0xFFFFFFFF
	mov r2,#0x40000000

@	strb r1,[r2]	@ b是byte的意思,指令译为写入一个字节
	strh r1,[r2]	@ h是halfword的意思  占两个字节
					@什么后缀都不加的话, 默认是一个词, 也就是四个字节
					@ldr指令同样支持以上后缀


```



### ARM指令的寻址方式

```
@寻址方式就是CPU去寻找一个操作数的方式(一共有九种)
@	mov r1,#1			@立即寻址  
@	add r1,r2,#1		
	
@	add r1,r2,r3		@寄存器寻址
	
@	mov r1,r2,lsl #1	@寄存器移位寻址
	
@	str r1,[r2]			@寄存器间接寻址

	@内存访问指令
	@基址加变址寻址

@	mov r1,#0xFF000000		@将r1寄存器中的数据写入到r2+r3指向的内存空间
@	mov r2,#0x40000000	
@	mov r3,#4
@	str r1,[r2,r3,lsl #1]	@等价于r2+(r3<<1)
							@将r1寄存器中的数据写到r2+(r3<<1)指向的内存空间
	

	@基址加变址寻址的索引方式

@	mov r1,#0xFF000000		@前索引
@	mov r2,#0x40000000
@	STR R1,[R2,#8]			@将r1寄存器中的数据写入到r2+8指向的内存空间
	
@	mov r1,#0xFF000000		@后索引
@	mov r2,#0x40000000		@将r1寄存器中的数据写到r2指向的内存空间,然后r2自增8
@	STR R1,[R2],#8

@	mov r1,#0xFF000000		@自动索引(地址后面加!)
@	mov r2,#0x40000000		@将r1寄存器中的数据写入到r2+8指向的内存空间 且 r2自增8
@	STR R1,[R2,#8]!
	
```

## D8栈的种类与应用

### 多寄存器的内存访问指令

```

	@多寄存器内存访问指令
	@写入

@	MOV r1,#1
@	mov r2,#2
@	mov r3,#3
@	mov r4,#4
@	mov r11,#0x40000020
@	stm r11,{r1-r4}		@将r1-r4寄存器中的数据存储到内存以r11为起始地址的内存中
	

	@读取 LDM

@	ldm r11,{r6-r9}		@将内存中以r11为起始的数据读取到r6-r9寄存器
	

	@当寄存器不连续式,适用逗号分隔

@	stm r11,{r1,r3,r4}
@	stm r11,{r4,r1,r3}	@不管寄存器列表中的顺序如何,存储到内存时,永远都是小端排序
	
@	stm r11!,{r1-r4}	@自动索引一样适用于多寄存器内存访问指令	
```

### 多寄存器内存访问指令的寻址方式

![image-20210803111306116](F:/Typora/image-20210803111306116.png)

 increase after

 increase before

decrease after

decrease before

@after 则地址指向最后以一个数据
@before 则地址指向最后一个数据的下一地址
@in 则存入方式为队列
@de 则存储方式为栈

### 栈的种类与应用

栈的概念: 栈的本质就是一段内存,用于存储程序运行时的临时数据,如: 局部变量,函数的参数,返回值,程序跳转的时候需要保护的寄存器等

> 栈的分类: 
>
> 增栈:压栈时栈指针越来越大,出栈时指针越来越小
>
> 减栈: 压栈时栈指针越来越大,出栈时指针越来越小
>
> 满栈:栈指针指向最后一次压入到栈中的数据,压栈时需要先移动栈指针到相邻位置然 后再压栈
>
> 空栈: 栈指针指向最后一次压入到栈中的数据的相邻位置,压栈时可直接压栈,之后需要将栈指针移动到相邻位置

栈分为空栈(EA),空减(ED),满增(FA),满减(FD) 四种

ARM处理器一般使用==满减栈==



### 栈的应用举例



#### 	叶子函数的调用过程举例

​	

```


	@初始化栈指针

@	mov sp,#0x40000020	@使用栈指针前需要初始化 
	
@MAIN:
@	mov r1,#3
@	mov r2,#5
@	bl FUNC
	
@	add r3,r1,r2
@	b STOP
	
@FUNC:
@	stmfd sp!,{r1,r2}	@压栈保护现场	
@	mov r1,#10
@	mov r2,#20
@	sub r3,r2,r1
@	ldmfd sp!,{r1,r2}	@出栈恢复现场
@	mov pc,lr
	
	
```

​	



#### 	非叶子函数的调用过程举例

​	

```
mov sp,#0x40000020	@使用栈指针前需要初始化 



MAIN:
	mov r1,#3
	mov r2,#5
	bl FUNC1
	

	add r3,r1,r2
	b STOP

FUNC1:
	stmfd sp!,{r1,r2,LR}	@压栈保护现场	
	mov r1,#10
	mov r2,#20
	bl FUNC2
	sub r3,r2,r1
	ldmfd sp!,{r1,r2,LR}	@出栈恢复现场
	mov pc,lr
	
FUNC2:
	stmfd sp!,{r1,r2}
	mov r1,#7
	mov r2,#8
	mul r3,r1,r2
	ldmfd sp!,{r1,r2}
	mov pc,lr


```

#### 关于C语言的补充说明:

> 1. c语言就是树状结构,有且只有一个main (根)
> 2. 把不会调用其他函数的函数称为叶子函数(就是末端函数)
> 3. 叶子函数的LR(不会被覆盖),所以没必要压栈
> 4. 非叶子函数的LR(会被覆盖),所以LR也会被压栈保存
> 5. 栈中的数据出栈后并不会被清除, 局部变量不初始化的情况下,值就是上一次使用过的值(随机的)
> 6. 全局变量  放在(BSS段),即使不初始化的状态,使用前也会被清零



## D9专用指令

### 状态存器传送指令

```
@状态寄存器传送指令: 访问CPSR寄存器
@	mov r1,CPSR    @mov 操作不了CPSR
	
@	mrs r1,CPSR		@读操作 r1=CPSR
	
@	msr CPSR, #0x10	@写操作 
	
@	msr CPSR,#0xD3 	@SVC 模式可以修改,usr模式下不可以修改,非特权模式
```



### 软中断执行

```
@异常向量表

@	B main 		@跳转自身的意思	
@	B .
@	B FUNC1
@	B .
@	B .
@	B .
@	B .
@	B .
@main:
@	mov sp,#0x40000020 		@初始化栈指针 svc/usr 两种模式都独占一个栈指针,不通用
							@这条指令改的就是svc模式下的sp
@	msr CPSR, #0x10 
@	mov r1,#1
@	mov r2,#2
@	swi #1				@ #1对应磁盘 #2对应网卡
@	add r3,r2,r1
@	b STOP

@FUNC1:
@	stmfd SP!,{R1,R2,LR}
@	mov r1,#10
@	mov r2,#20
@	sub r3,r2,r1
@	ldmfd SP!,{R1,R2,PC}^   @"^"模式恢复  也就是 spsr的值给到cpsr
							@这条指令 恢复地址,恢复状态,跳转恢复完成
```

备注:

> swi 在linux内核中应用很多
> usr模式不能直接修改cpsr, 当代码执行write()函数时,
> linux内核就会调用一次swi软中断, cpu就会
> 切换到svc模式, 拥有更高的权限, 才能对硬盘进行读写



### 协处理器指令

```
@协处理器指令:操做协处理器的指令
@	1.协处理器数据运算指令
@	CDP
@	2.协处理器存储器访问指令
@	STC		将协处理器中的数据存储到存储器
@	LDC		将存储器中的数据读取到协处理器中
@	3.协处理器寄存器传送指令
@	MRC		将协处理器中寄存器的数据传送到ARM处理器中的寄存器
@	MCR		将ARM处理器寄存器中的数据传送到协处理器中的寄存器
```

备注:

> ARM允许最多外加16个协处理器
> FPU :处理浮点型数据协处理器
> cp15:管理存储器的协处理器:高速缓存,异常向量表,MMU(存储器管理单元:物理地址和虚拟地址的转换或者映射)



### 伪指令

伪指令:本身不是指令,编译器可以将其替换成若干条指令,本身不能执行,编译的时候会被替换
	

```
@	NOP   	@空指令 机器码: ELA00000,等价于 mov r0,r0	占用指令周期
@	mov r0,r0
	

@指令
LDR	r1,[r2]
@伪指令
LDR r1, =0x12345678		@r1 = 0x12345678, 可以将任意一个32位的数据放到寄存器中

LDR r1, =STOP	@将stop的地址写入r1寄存器中

LDR r1,STOP		@将stop地址中的内容给r1

STOP:
	B STOP
```

## D10伪操作与混合编程

### 伪操作

```
@伪操作:不会生成代码,只是在编译阶段告诉编译器怎样编译
	@ .GNU伪操作一般都以'.'开头
	

	@.golbal symbol		将symbol声明成全局
	@.local	 symbol		将symbol 声明成局部
	
	@.equ DATA, 0xFF	将DATA等价于0xFF, 类似于C语言中的宏,不会生成代码
	@mov r1,#DATA
	
	@.macro FUNC			@对汇编指令的一个封装,
	@	mov r1,#1
	@	mov r2,#2
	@.endm
	
	@FUNC					@对封装的汇编的调用

@	.if 1					@条件编译,编译时会先判断条件,
@		mov r1,#1
@		mov r2,#2
@	.endif
	
@	.rept 3					@重复编译
@		mov r1,#1
@		mov r2,#2
@	.endr
	
@	.weak func			@某个符号用到了,但是没定义,编译的时候也不要报错
@	B func				@.weak func 会被编译成空操作
	
					
@	mov r1,#1			@在当前地址申请一个字的空间,并初始化
@	.word 0xFFFFFFFF	
@	mov r2,#2
	
@	mov r1,#1			
@	.byte 0xFF			@在当前地址申请一个字节的空间
@	.align 2			@对其伪操作, 2的意思 是2^2 也就是4 字节对其
@	mov r2,#2
	
@	.arm				@两种模式的指令
@	.thumb
	
@	.text				@后面码段
	
@	.end				@汇编代码结束

@	.space 12,0x12			@在当前地址申请任意个字节的空间并将其初始化
	
@	指令和伪指令 是由ARM公司来定义的
@	伪操作 是不同的编译器的语法不一样,根据不同编译器而不同(gcc)
```



### C和汇编的混合编程

@这三类是通用指令CPU都有
	@1.数据处理指令
	@2.跳转指令
	@3.load/stor指令
	

@这三类指令就不是通用指令,ARM有,别的CPU不一定有
@1.状态寄存器传送指令
@2.软中断指令
@3.协处理器指令

@c和汇编混合编程的原则:在那种语言环境下符合那种语言的语法规则
@1:在汇编语言中将C语言中的函数当做标号来处理
@2:在C语言中将汇编语言的标号当做函数来处理
@3:c内联汇编

```
@c和汇编混合编程
@三种格式
@1.汇编语言调转(跳转)c语言

@		mov r1,#1
@		mov r2,#2
@		BL func_c
@		mov r3,#3
	

	@2.c语言调用(跳转)汇编语言

@	.global FUNC_ASM
@FUNC_ASM:
@		mov r4,#4
@		mov r5,#5
	

	@3.c内联汇编

void func_c(void)
{
	int a,b;
	a++;
		

	asm
	(
		"mov r6,#6\n"
	  "stmfd, sp!,{r1,r2}\n"
		"mov r7,#7\n"
		
	);
	
	FUNC_ASM();
	a--;

}
```



### ATPCS协议

```
@ATPCS 协议  	ARM/thumb process call standard 程序调用标准
	@协议的主要内容
	

	@1.栈:使用满减栈
	
	@2.寄存器:r15 程序计数器,只能用于存储程序指针.
	@		  r14 链接寄存器,只能用于存储返回地址.
	@		  r13 栈指针,只能用于存储栈指针.
	@		  其余的寄存器主要用来存储局部变量
	
	@3.参数传递: r0-r3	当函数的参数少于4个的时候,使用r0-r3传参,多出4的部分用栈传递
	@		  r0 负责存储函数的返回值

### 
```

### ARM体系结构总结





## D11FS4412开发环境搭建

### 开发板硬件资源介绍

三星造ARM四核CPU

四个256的内存

EMMC芯片(硬盘:即断电不丢失)

电源管理芯片

### 初识电路原理图



### 交叉开发环境搭建



### 地址映射表

1.数据运算指令

2.跳转指令

3.load/store

4.状态寄存器传送指令

5.SWI 软中断指令

6.协处理器指令



通过STR/LDR 进行交互的资源:

> ROM:程序寄存器(断电不丢失)(只读存储器)
>
> RAM:数据寄存器(断电丢失)
>
> IO(SFR): 网卡 USB UART ADC RTC PGIO
>
> RSV:==没讲作用==



硬件控制原理:

> cpu本身不能控制硬件,硬件一般由其对应的控制器来控制,SOC中将各个硬件控制器的寄存器映射到了CPU地址空间的一段范围,这样CPU就可以通过读写寄存器来间接控制硬件.
>
> (这里的寄存器在SOC中但在CPU之外,有地址,访问方式与内存一样,常用于控制硬件)

地址映射表:

在一个处理器中,一般会将flash,ARM,寄存器等存储设备分别映射到寻址空间的不同地址段,我们将这个映射关系称为这个处理器的地址映射表

![image-20210806094042401](F:/Typora/image-20210806094042401.png)



## D12GPIO实验

### GPIO简介

(peneral-purpose input/output)

通用型输入输出,可以控制连接在其上的引脚实现信号的输入输出, 芯片的引脚与外部相连,从而实现与外部设备的通讯,控制及信号采集等功能

实验步骤:

1. 通过电路原理图分析LED的控制逻辑

   高电平点亮,低电平熄灭

2. 通过电路原理图查找LED与Exynos4412的连接关系

   GPX2_7

3. 通过数据手册分析GPIO中哪些寄存器可以控制LED

   304个多功能引脚  分成37组

   > GPA0/GPA1: 14个引脚 :3个串口(3 * UART)  /  2 * I^2^C
   >
   > GPB:8个引脚: 2 * SPI / 2 * I^2^C / IEM
   >
   > GPC
   >
   > GPD
   >
   > GPM
   >
   > GPF
   >
   > GPJ
   >
   > GPK
   >
   > GPL
   >
   > GPX: 32个引脚     GPX2: 八个引脚   GPX2CON(起始位置:0x11000c40)
   >
   > GPY
   >
   > GPZ

   

   GPX2CON[0]:     3:0	RW	

   discraption: 

   > 0000 input
   >
   > 0001 output
   >
   > 0010 reservered
   >
   > 0011 KP_ROW[0]
   >
   > 0100 reservered
   >
   > 0101 ALV_DBG[12]
   >
   > 0110 to 0xE = reservered
   >
   > 1111 WAKEUP_INT2[0]

   

   GPX: 32个引脚     GPX2: 八个引脚   GPX2CON(起始位置:0x11000c40)(一共32位)

   0:3 		2_0这个引脚

   4:7 		2_1这个引脚

   28:31 	2_7这个引脚 0001 输出 状态

   

   GPX2DAT (0x11000c44)

   32位中, 高位没用, 只用了最低的八位,每一位对应一个引脚, 

   第七位对应GPX2_7, 1就是高电位, 0就是低电位

   控制LED亮和灭

   

   164个存储器引脚 分成2组

   

4. 通过程序去操作对应的寄存器完成对LED的控制

### GPIO寄存器分析

### GPIO编程

### LED实验

```
.text

_start:

MAIN:
	BL LED_CONFIG
LOOP:	
	BL LED_ON

	BL DELAY
	BL LED_OFF
	BL DELAY
	B LOOP

LED_CONFIG:
	LDR R2, =0x11000c40
	LDR R1, =0x10000000
	STR R1,[R2]
	MOV PC,LR

LED_ON:
	LDR R2, =0x11000c44
	LDR R1, =0x00000080
	STR R1, [R2]
	MOV PC,LR

LED_OFF:
	LDR R2, =0x11000c44
	LDR R1, =0x00000000
	STR R1,[R2]
	MOV PC,LR

DELAY:
	LDR R1, =100000000
L:
	SUB R1, R1,#1
	CMP R1, #0
	BNE L
	MOV PC,LR

STOP:
	B STOP

.end
```



## D13C工程与寄存器封装

### C语言工程简介

> 1. common源代码   
> 2. map.led链接脚本  
> 3. start启动代码  
> 4. makefile 编译 
> 5. interface.c 程序

### 启动代码分析

### C语言实现LED实验

![image-20210815161348684](F:/Typora/image-20210815161348684.png) 

### 寄存器的封装方式

### 寄存器操作的标准化

## D14 UART实验

### UART帧格式详解

UART 就是一种通信协议

也叫串口:全双工的发送和接收协议,嵌入式应用广泛

![image-20210808110651511](F:/Typora/image-20210808110651511.png)

通信基础:

单工通信:

双工通信:

> 1. 半双工:A给B发时,B不能给A发
> 2. 全双工:A给B发时,B也能给A发

![image-20210808111703388](F:/Typora/image-20210808111703388.png)

波特率:描述串口通信速度(bps: bit per second)

UART帧格式:

![image-20210808112730304](F:/Typora/image-20210808112730304.png)

串口是异步通信: 收发双方用的不是一个时间基准., UART中的运行频率是100Mdps



UART控制单元结构图

![image-20210808141312221](F:/Typora/image-20210808141312221.png)



串口控制器的原理及使用方法

接收: 引脚 移位器 缓冲区

发送: 缓冲区 移位器 引脚

> SP3232EEA 芯片
>
> 这个是很常见的TTL串口信号转换成RS232串口信号的电平转换芯片。此芯片价格比美信max3232价格低很多，性能可靠，是很好的替代。用量极大

### UART寄存器详解

5套串口控制器的寄存器

串口1 寄存器基地址 0x1380_0000

串口2 寄存器基地址 0x1381_0000

串口3 寄存器基地址 0x1382_0000

串口4 寄存器基地址 0x1383_0000

串口5 寄存器基地址 0x1384_0000(==GPS 独占==)

串口控制器寄存器介绍:

> 1.ULCONn 控制串口通信的帧的格式
>
> 2.UCONn 控制发送和接收模式
>
> 3.UFCONn 接收和发送队列FIFO 的控制
>
> 4.UMCONn 自动流控制
>
> 5.UTRSTATn 发送和接收状态寄存器
>
> 6.UERSTATn 错误状态及类型寄存器
>
> 7.UFSTATn 收发队列状态寄存器
>
> 8.UMSTATn 流控制状态寄存器
>
> 9.==UTXHn== 发送缓冲区寄存器
>
> 10.==URXHn== 接收缓冲区寄存器
>
> 11.UBRDIVn 设置串口通信速度:  分频数的整数部分
>
> 12.UFRACVALn 设置串口通信速度 :  分频数的小数部分
>
> 13.UINTPn 设置串口中断功能:	
>
> 14.UINTSPn 设置串口中断功能
>
> 15.UINTMn 设置串口中断功能

 

ULCONn 设置明细

> ![image-20210808153729870](F:/Typora/image-20210808153729870.png)
>
> 模式设置位 (有线/红外)
>
> 校验位  	0xx (只要是第三位为0,则就是无校验模式)
>
> 停止位 
>
> 数据长度位



UCONn 设置明细

1

![image-20210808154830180](F:/Typora/image-20210808154830180.png)

2

![image-20210808155037715](F:/Typora/image-20210808155037715.png)

receive: 

> 轮询(CPU不断读取队列)
>
> 中断(CPU等待中断信号)
>
> DMA (直接寄存器访问,不经过CPU)



### UART编程





### 输入输出重定向





## D15 WDT实验

### WDT简介(Watch Dog Timer)

WDT看门狗计时器,主要作用是当发生软件故障时可以产生复位信号使SOC复位,其本质上是一个计数器(定时器)

CPU运行时 "定时喂狗",否则"狗饿死", 发送信号给CPU, CPU重启.



### Exynos4412

1.DWT作为一个普通的定时器: 中断信号

2.DWT监控CPU, 值为零时:复位信号

3.结构原理图:

![image-20210810094816522](F:/Typora/image-20210810094816522.png)

1.  PCLK 时钟,频率为 100M(一个亿),递减周期计算=PCLK/(一级+1)/二级
2. 分频器一级: 降低频率(八位:0~255,) 1~256倍  由WTCON[15:8] 位来控制
3.  分频器二级:降低频率(两位:0~3,)4档  由WTCON[4:3]位来控制   
4. 递减计数器: WTCNT(寄存器)(值自动减)/WTDAT(实时中断信号的时间数据)
5. 触发信号: 普通定时器:中断信号 WTCON[2] / 监控CPU运行: 复位信号 WTCON[0]



### WDT寄存器详解



![image-20210810101905365](F:/Typora/image-20210810101905365.png)



![image-20210815161202171](F:/Typora/image-20210815161202171.png)

### WDT编程



## D16轮询与中断

### CPU与硬件的交互方式

轮询 : 

CPU执行程序时不断地问硬件是否需要其服务,若需要则给与其服务,若不需要一段时间后再次询问,周而复始

中断:

CPU执行程序时若硬件需要其服务,对应的硬件给CPU发送中断信号.CPU接收到中断信号后将当前程序停下来,转而去执行中断服务程序,执行完成后再返回到被打断的点继续执行

DMA

硬件产生数据后,硬件控制器可将产生的数据需CPU的参与

### 轮询方式实现按键试验

键位电路图

![image-20210811143823054](F:/Typora/image-20210811143823054.png)



### GPIO中断相关寄存器详解



### GPIO中断编程

GPX1CON[1] : 0xF 中断信号 有无

filter 滤波寄存器 31:0 以设置好的模式过滤 噪声和干扰

mask 屏蔽寄存器 7:0 中断信号的使能和屏蔽 

pend 挂起寄存器 7:0 CPU正在处理其他中断程序， 现有的中断程序无法被立即执行，则现在的 								  中断信号被挂起，等待CPU资源。



## D17中断控制器

### 中断控制器

外部设备一共有160 个使能的中断信号，CPU没法直接判断和处理这些信号

中断控制器：负责统一管理和控制这些中断信号

> 1. 多个中断同时产生时可对这些中断挂起排队，然后按照优先级依次发送给CPU处理
> 2.  可以为每一个中断分配一个优先级
> 3. 一个中断正在处理时若又产生其它中断，可将新的中断挂起，待CPU空闲时再发送
> 4.  可以为每一个中断选择一个CPU处理
> 5.  可以为每一个中断选择一个中断类型（FIQ或IRQ）
> 6.  CPU接收到中断信号后并不能区分是哪个外设产生的，此时CPU可查询中断控制器 
> 7.  来获取当前的中断信号是由哪个硬件产生的，然后再进行对应的处理
> 8.  可以打开或禁止每一个中断
> 9.  ... ...

​		



![image-20210812140142723](F:/Typora/image-20210812140142723.png)



### 4412下的中断控制器

Software Generated Interrupt(SGI) (一般是CPU间的通讯机制, 由中断控制器调用)(不是之前学的那个软终端) (15:0)

Private Peripheral Interrupt(PPI)	(私有外设中断,由特定CPU处理的外设中断) (31:16)

Shared Peripheral Interrupt(SPI)	(共享外设中断,多核处理器中,哪个处理器都可以处理的中断)

(159:32) (最常用的)



GPX1_1 :  	EINT9(外部中断9) 	 序号 57  本次实验要用到的寄存器引脚



### 中断控制器寄(GIC)存器详解

五个寄存器管理一共160个中断的开和关: 五个(32位)寄存器0x1049_0100~0110

<P805>

![image-20210812162749565](F:/Typora/image-20210812162749565.png)

由图可知 0x0104 的第25位是我们要用到的序号57的寄存器位(bit)

即: ICDISER1_CPU0 : 25

160*8bit: 一共40个寄存器来负责设置每个中断由哪个CPU来处理 

### 中断控制器编程

## D18中断处理

### ARM的异常处理机制

 导致异常产生的事件称为异常(并不是错误, 是一种处理问题的逻辑)

 ARM异常源

FIQ	快速中断请求引脚有效

IRQ	外部中断请求引脚有效

Reset

...,...

五种异常模式

![image-20210814094804291](F:/Typora/image-20210814094804291.png)

### 工程模板代码结构分析

common :各种头文件 和 封装好的 函数

start : 包含一个启动代码, 控制C语言运行之前的汇编代码, 初始化设备

map.lds : 生成 ".bin"文件的排版结构

### 中断处理框架搭建

R14  "LR" 链接寄存器, 当程序跳转时,自动保存原程序下一条代码的地址,程序需要返回时,只需要 PC = LR即可实现

### 中断处理程序编程



### 中断编程补充



## D19 ADC实验

### ADC简介

Analog to Digital Converter 模数转换器,指一个能将模拟信号转化成数字信号的电子元件

分辨率: (精度)

### 4412下的ADC控制器

VR1 ->XadcAIN3

![image-20210815100615033](F:/Typora/image-20210815100615033.png)



![image-20210815100743505](F:/Typora/image-20210815100743505.png)

ADC专用引脚

1M就是100万

![image-20210815101255456](F:/Typora/image-20210815101255456.png)

主要第一条和最后一条, 

10位/12位可选

0~1.8v电压可输入



PCLK 100M 给到ADC, 分频器分频, ADC- CLK / 5, 得到1MHz , 不得超过1MHz

![image-20210815102533513](F:/Typora/image-20210815102533513.png)

### ADC寄存器详解

![image-20210815103623757](F:/Typora/image-20210815103623757.png)

ADCCON 配置寄存器

ADCDLY 延迟寄存器 略

ADCDAT 存储转化结果

CLRINTADC 中断相关 略

ADCMUX 选择转化通道 

![image-20210815110817366](F:/Typora/image-20210815110817366.png)

ADCCON 配置寄存器

32位 

17~32位 保留

0~16 位 有用 

16: 0: 10位精度 / 1: 12位精度

15: 只读, 0是正在转化, 1 是转化完成

14: 分频器使能

13~6: ADC 分频器设置 19~255 (实际倍数要加1)  极限小为1MHz, 低于19 就会超过19, 会出错

5~3 保留

2: standby 待机模式, 0为正常, 1 为低功耗待机

1: 设置 ADC  1 读取结果, ADC继续转换. (auto)

0: 设置 ADC  1 就 开始, 且 此位置0, (manul)

![image-20210815112221287](F:/Typora/image-20210815112221287.png)

ADCDAT 存储转化结果  

共32位 一共 12 位占用 只读

高20 位要清零



![image-20210815112552962](F:/Typora/image-20210815112552962.png)

ADCMUX 选择转化通道

用哪个选哪个

### ADC编程



## D20 RTC实验

### RTC简介

实时时钟(real time clock) 

是一个可以为系统精确时间基准的元器件, RTC一般采用精度较高的晶振作为时钟源,有些RTC有外加电池供电, 主电源掉电也可以继续工作, 此时钟 不与其他模块共用.

### 4412下的RTC控制器

![image-20210816090512570](F:/Typora/image-20210816090512570.png)



工作逻辑图

![image-20210816092244056](F:/Typora/image-20210816092244056.png)





### RTC寄存器详解

![image-20210816093025867](F:/Typora/image-20210816093025867.png)

(BCD码, 就是 用二进制表示10进制的数)

> 1. 所以BCD打头的寄存器就是以BCD码表示的时间
> 2. 以ALM打头的寄存器就是警告(闹铃)功能的预定时间
> 3. INTP 中断挂起寄存器
> 4. RTCCON 控制寄存器
> 5. TICCNT 滴答时钟寄存器
> 6. RTCALM 闹钟控制寄存器
> 7. CURTICCNT 滴答时钟计数控制器





### RTC编程

## D21PWM实验

### PWM简介

有源蜂鸣器: 只要接上额定电源就可以发出声音

无源蜂鸣器: 利用电磁感应原理,为音圈接入交变电流后形成的电磁铁与永磁磁铁相吸或推动振膜发声

![image-20210817085804944](F:/Typora/image-20210817085804944.png)



PWM(pulse width modulation )脉冲宽度调制, 通过对脉冲的宽度进行调制, 来获取所需波形

![image-20210817090410005](F:/Typora/image-20210817090410005.png)

PWM的参数: 

​	周期 :  

​	占空比:

![image-20210817090627979](F:/Typora/image-20210817090627979.png)



### 4412下的PWM

![image-20210817091124706](F:/Typora/image-20210817091124706.png)

4412 一共有5 个PWM, 前四个(0,1,2,3)可输出 信号, 第五个 不可向SOC外部输出,

蜂鸣器用的是GPD0_0 (独有 死区功能, 大电流不损坏设备的功能)



分频:

PWM用的是PCLK 时钟源(100M), PWM内部有个8位(1~256倍)可编程分频器,  (0和1 共用一个一级分频器) (2,3,4 共用另一个一级分频器) (五个PWM 各自独占一个二级分频器: 2,4,8,16)

example: 

![image-20210817094003466](F:/Typora/image-20210817094003466.png)

(周期) TCNTB = 159

(占空比) TCMPB = 109



PWM逻辑框架

![image-20210817101144304](F:/Typora/image-20210817101144304.png)

PWM有反向输出功能, 即 高低电平对调.

### PWM寄存器详解

![image-20210817102653485](F:/Typora/image-20210817102653485.png)

> 1. TCFG0 设置8位预分频器 和死区宽度的
> 2. TCFG1 设置二级分频的
> 3. TCON    PWM控制寄存器
> 4. (周期) TCNTB = 159
> 5. (占空比) TCMPB = 109
> 6. TCNTO0: 存储递减计数器里的具体数值,
> 7. TCNTBn
> 8. TCMPBn
> 9. TCNTOn     这仨是设置PWM n 的 

![image-20210817104302793](F:/Typora/image-20210817104302793.png)

23:16 死区宽度,  略

15:8 一级预分频器 1

7:0  一级预分频器 0





 二级分频器寄存器  分为5组, 给到五个分频器

![image-20210817104731551](F:/Typora/image-20210817104731551.png)





TCON    PWM控制寄存器

![image-20210817105046456](F:/Typora/image-20210817105046456.png)

![image-20210817105424875](F:/Typora/image-20210817105424875.png)

4   设置死区的开和关(默认为关)

3	设置PWM0 的自动装载 开和关 (周期自动循环)

2	设置高低电平对调的寄存器

1	设置 第一个周期TCNTB的值给到 递减计数器 的 使能 寄存器

0	PWM0 的使能设置





![image-20210817111300269](F:/Typora/image-20210817111300269.png)

周期, 空占比, 递减计数器计数值(此值 只读)





### PWM编程





## D22 IIC总线原理

### IIC总线概述

IIC总线是一种串行,半双工总线

1.  结构与应用:

   用于近距离,低速的,芯片间的通信, IIC总共有两根双向的信号线,一根数据线SDA用于收发数据, 一根时钟线SCL 用于通信双方时钟的同步, IIC总线硬件结构简单,成本较低,应用广泛

   ![image-20210818091231479](F:/Typora/image-20210818091231479.png)

2.  IIC总线上的==主机与从机==

   IIC总线是一种多主机总线, 连接在IIC总线上的器件分为主机和从机,主机有权发起和结束一次通信,而从机只能被主机呼叫,当总线上有多个主机同时启用总线时, IIC	也具备冲突检测和仲裁的功能来防止错误产生, 每个连接到总线上的器件都有一个唯一的地址(7bit),且每个器件都可以作为主机或者从机(同一==时刻==只能有一个主机),总线上的器件增加和删除不影响其他器件正常工作, IIC总线在通信时总线上发送数据的为发送器, 接收数据的为接收器

   ![image-20210818091213557](F:/Typora/image-20210818091213557.png)

3.  IIC总线通信过程

   > 1. 主机发送起始信号启用总线
   > 2. 主机发送一个字节数据指明从机地址和==后续字节的传送方向==
   > 3. 被寻址的从机发送应答信号回应主机
   > 4. ==发送器==发送一个字节数据
   > 5. ==接收器==发送应答信号回应发送器
   > 6. ...	,	... (步骤4,5 循环)
   > 7. 通信完成后主机发送停止信号释放总线

### IIC总线信号实现

1. 起始信号

2. 数据信号

3. 应答信号

4. 停止信号

   SCL / SDA 空闲时都是高电平

   同步机制

   ![image-20210818104248582](F:/Typora/image-20210818104248582.png)



![image-20210818104355689](F:/Typora/image-20210818104355689.png)



![image-20210818104412209](F:/Typora/image-20210818104412209.png)





### IIC典型时序 

三种方式

![image-20210818200902834](F:/Typora/image-20210818200902834.png)



![image-20210818200917352](F:/Typora/image-20210818200917352.png)



## D23 IIC控制器与MPU6050

### 4412下的IIC控制器

Inter-Integrated Circuit (I2C)

SDA(Serial Data line)/SCL(Serial Clock line)

![image-20210819085530469](F:/Typora/image-20210819085530469.png)

> 1. 控制寄存器
> 2. 状态寄存器
> 3. 发送/接受 寄存器
> 4. 地址寄存器

100~400 kbit/s

主发/主接/从发/从接 四种模式

轮询/中断



IIC控制逻辑

![image-20210819091023282](F:/Typora/image-20210819091023282.png)



### IIC控制器详解

![image-20210819094630522](F:/Typora/image-20210819094630522.png)

控制/状态/地址/发送接收/滤波及延时 五个寄存器



一 (控制)

![image-20210819095814033](F:/Typora/image-20210819095814033.png)

> 1. 7	应答信号 开关
> 2. 6	时钟源(决定了4412 自己的IIC的通信速度)(也要考虑目标芯片的通信速率)
> 3. 5	中断信号 开关
> 4. 4	中断挂起标志位(数据发送或接受状态标志位)(用完数据, 记得清零标志位)
> 5. 3:0 时钟分频器



二(状态)

![image-20210819101119774](F:/Typora/image-20210819101119774.png)

> 1. 7:6 四种模式选择
> 2. 5	起始或终止信号
> 3. 4	接受或发送 开关
> 4. 3	2	1	0 只读 略



三(地址)

![image-20210819101603826](F:/Typora/image-20210819101603826.png)

4412 的地址 寄存器



四(移位) (发送接收 位)

![image-20210819101742195](F:/Typora/image-20210819101742195.png)



五(滤波/延迟)  略



### MPU6050原理

1.  简介: 

   运动处理传感器,内部集成了三轴加速度传感器和三轴陀螺仪(角速度传感器), 以及一个可扩展的数字运动处理器

2. 功能及参数

    可测量X、Y、Z轴三个方向的角速度

     可编程设置角速度测量范围为±250、±500、±1000、±2000°/sec

     可测量X、Y、Z轴三个方向的加速度

     可编程设置加速度测量范围为±2g、±4g、±8g、±16g

     可编程设置低功耗模式

     可编程设置采样频率 

3. 通信接口

   MPU6050可以使用IIC总线和其他器件进行数据交互，我们可以使用IIC总线向MPU6050中的控制寄存器写入数据来设置MPU6050的工作参数

   也可以使用IIC总线从MPU6050中的数据寄存器读取数据来获取加速度、角速度等信息

   ![image-20210819103626305](F:/Typora/image-20210819103626305.png)

![image-20210819112645107](F:/Typora/image-20210819112645107.png)





### MPU6050寄存器读写时序

/**MPU6050内部常用寄存器地址**/

#define	SMPLRT_DIV		0x19	//陀螺仪采样率,典型值:0x07(125Hz)
#define	CONFIG			0x1A	//低通滤波频率,典型值:0x06(5Hz)
#define	GYRO_CONFIG		0x1B	//陀螺仪自检及测量范围,典型值:0x18(不自检,2000°/s)
#define	ACCEL_CONFIG	0x1C	//加速计自检及测量范围及高通滤波频率,典型值:0x0(不自检,2G,5Hz)
#define	ACCEL_XOUT_H	0x3B
#define	ACCEL_XOUT_L	0x3C
#define	ACCEL_YOUT_H	0x3D
#define	ACCEL_YOUT_L	0x3E
#define	ACCEL_ZOUT_H	0x3F
#define	ACCEL_ZOUT_L	0x40
#define	TEMP_OUT_H		0x41
#define	TEMP_OUT_L		0x42
#define	GYRO_XOUT_H		0x43
#define	GYRO_XOUT_L		0x44
#define	GYRO_YOUT_H		0x45
#define	GYRO_YOUT_L		0x46
#define	GYRO_ZOUT_H		0x47
#define	GYRO_ZOUT_L		0x48
#define	PWR_MGMT_1		0x6B	//电源管理,典型值:0x00(正常启用)
#define	SlaveAddress	0x68	//MPU6050-I2C地值 

![image-20210819134935308](F:/Typora/image-20210819134935308.png)





![image-20210819135010306](F:/Typora/image-20210819135010306.png)



### IIC编程



## 补充:汇编所有指令表格

| 指令名+格式                                                  | 指令作用                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| mov r1,#15                                                   | 把数据15移入寄存器r1中                                       |
| mvn r0,#22                                                   | 数据取反再存入寄存器r0中                                     |
| add r1,r2,r3<br />add r1,r2,#5                               | 两个数相加不行, 数加R 也不行, 有格式限制<br/>操作码+目标寄存+第一操作寄存器+第二操作数<br />(可以是寄存器或立即数) |
| sub R1,R2,R3                                                 | r1=r2-r3<br />只能寄存器-一个数,或者寄存器-寄存器            |
| rsb R2,R2,#3                                                 | 逆向减法指令<br />R1=3-R2                                    |
| MUL R1,R2,R3                                                 | R1=R2*R3<br />乘法指令只能是两个寄存器相乘                   |
| AND r1,r2,r3                                                 | 按位与<br />r1=r2 & r3                                       |
| ORR r1,r2,r3                                                 | 按位或<br />r1=r2 \| r3                                      |
| EOR R1,R2,R3                                                 | 按位异或<br />R1=R2 ^ R3 	相同为0 相异为1                 |
| lsl r1,r2,r3                                                 | 左移<br /> r1=(r2<<r3)	R2 左移 R3 位                      |
| LSR r1,r2,r3                                                 | 右移<br />r1=(r2>>r3)                                        |
| MOV R2,#0xff<br />BIC r1,r2,#0x0F                            | 位清零<br />把r2后四位清零后,结果给到r1,  r2不受影响         |
| mov r1,r2,lsl #1                                             | 数据运算指令的格式扩展<br />r2左移一位,结果给到r1            |
| mov R1,#3<br />subs R2,R1,#5                                 | 数据运算指令对条件位(NZCV)的影响<br />默认情况下,数据运算不会对条件位产生影响,<br />当在指令后加后缀"s"可以影响 |
| MOV R1, #0xFFFFFFFF<br/>	MOV R2, #0x00000012<br/>	MOV R3, #0x00000021<br/>	MOV R4, #0x00000022<br/>	<br/>	ADDs R5,R1,R3<br/>	ADc  R6,R2,R4<br />    @R6=R2+R4+'C' | @两个64位的数据做加法运算<br />(带进位的加法指令)<br/>	@第一个数的低32位放在R1<br/>	@第一个数的高32位放在R2<br/>	@第二个数的低32位放在R3<br/>	@第二个数的高32位放在R4<br/>	@运算结果的低32位放在R5<br/>	@运算结果的高32位放在R6<br/>	<br/>	@	第一个数<br/>	@ 0x00000012 FFFFFFFF<br/>	@ 	第二个数<br/>	@ 0x00000022 00000021 |
| MOV R1, #0x00000001<br/>	MOV R2, #0x00000002<br/>	MOV R3, #0x00000005<br/>	MOV R4, #0x00000001<br/>	<br/>	SUBS R5,R1,R3<br/>	SBC	 R6,R2,R4 	<br />    @ R6=R2-R4-'C' | @带借位的减法指令<br/>	@	第一个数<br/>	@ 0x00000002 00000001<br/>	@ 	第二个数<br/>	@ 0x00000001 00000005 |
| main:<br/>	mov r1,#1	mov r2,#1<br/>	mov r3,#1<br/>	mov PC,#0x18<br/>	mov r4,#1<br/>	mov r5,#1<br/>	<br/>func:	<br/>	mov r6,#1<br/>	mov r7,#1<br/>	mov r8,#1 | @跳转指令:<br />实现程序的跳转,本质就是修改了PC寄存器<br />@方式一: 直接去修改PC寄存器的值<br />(不建议直接使?需要人为计算绝对地址,可行性较差) |
| main:<br/>	mov r1,#1	<br/>	mov r2,#1<br/>	mov r3,#1<br/>	b func<br/>	mov r4,#1<br/>	mov r5,#1<br/>	<br/>func:	<br/>	mov r6,#1<br/>	mov r7,#1<br/>	mov r8,#1 | 方式二: 通过不带返回的跳转指令, <br />本质上也是就该PC,<br />自动的寻址指令 |
| main:<br/>	mov r1,#1	<br/>	mov r2,#1<br/>	mov r3,#1<br/>	bl func<br/>	mov r4,#1<br/>	mov r5,#1<br/>	<br/>func:	<br/>	mov r6,#1<br/>	mov r7,#1<br/>	mov r8,#1<br/>	mov PC,LR | 方式三:带返回的跳转指令,<br />程序跳转后, R14(LR寄存器)<br />存储跳转前的下一条指令地址 |
| CMP,R1,R2	<br/>	<br/>	mov R1,#1<br/>	mov r2,#2<br/>	cmp r1,r2 <br/>	<br/>	beq func  	<br />@ 先做了一个判断,if(equl){B func}<br/>@本质就是 if(Z==1){B func}<br/>	bne func	<br/>@n就是no,判断数据不相等则...	<br/>	mov R3,#3<br/>	mov r4,#4<br/>	mov r5,#5<br/>	<br/>func:<br/>	mov R6,#6<br/>	mov r7,#7 | @ARM指令的条件执行<br />@比较指令<br />@结果存储在NZCV中,本质就是(subs), <br />只不过结果不保存而已,相减=0<br /> 则,z等于1, !=0,则z=0; |
| mov R1,#1<br/>@	mov r2,#2<br/>@	cmp r1,r2<br/>@	movgt r3,#3 | @ARM指令集中大多数都可以带条件码后缀                         |
| mov r1,#9<br/>	mov r2,#15<br/>START:<br/>	cmp R1,R2			<br />@比较R1,R2 寄存器中的数据的结果<br/>	<br/>@根据cmp的结果判断, <br />@下面三句代码只有一句会执行<br />	BEQ STOP			<br />	subgt r1,r1,r2<br/>	sublt r2,r2,r1<br/>	<br/>	b START				<br />@继续跳到START执行<br/>	<br/>@死循环,防止程序跑炸<br />STOP:			<br />	B STOP<br /> | @ 练习:通过汇编来实现如下代码<br />@	int R1 = 9;<br/>@	int R2 = 15;<br/>@START:<br/>@	if(R1==R2)<br/>@		stop();<br/>@	else if(R1>R2)<br/>@	{<br/>@		R1=R1-R2;<br/>@		goto START;<br/>@	}<br/>@	else if(R1<R2)<br/>@	{<br/>@		R2=R2-R1;<br/>@		goto START;<br/>@	} |
| mov r1,#0xFF000000<br/>	mov r2,#0x40000000<br/>	str r1,[r2]<br /> | @load/store 指令: 访问(读写)内存<br/>@写内存<br />@将R1寄存器中的数据存储到R2指向的内存空间 |
| ldr r3,[r2]	<br />                                        | @读内存<br />@将寄存器r2指向的内存空间中的数据<br />读取到r3寄存器 |
| mov r1,#0xFFFFFFFF<br/>mov r2,#0x40000000<br />strb r1,[r2]<br />strh r1,[r2] | @ b是byte的意思,指令译为写入一个字节<br/>@ h是halfword的意思  占两个字节<br/>@什么后缀都不加的话, 默认是一个词, <br />        也就是四个字节<br/>@ldr指令同样支持以上后缀 |
| mov r1,#1			  <br/>add r1,r2,#1                     | @寻址方式就是CPU去寻找一个操作数的方式<br />(一共有九种)<br />@立即寻址 |
| add r1,r2,r3                                                 | @寄存器寻址                                                  |
| mov r1,r2,lsl #1                                             | @寄存器移位寻址                                              |
| str r1,[r2]                                                  | @寄存器间接寻址                                              |



| 指令+格式                                                    | 指令作用                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| mov r1,#0xFF000000<br />mov r2,#0x40000000<br />mov r3,#4<br />str r1,[r2,r3,lsl #1] | @内存访问指令<br/>@基址加变址寻址<br />@将r1寄存器中的数据写入到r2+r3指向的内存空间<br />@等价于r2+(r3<<1)<br/>@将r1寄存器中的数据写到r2+(r3<<1)指向的内存空间 |
| mov r1,#0xFF000000<br />mov r2,#0x40000000<br />STR R1,[R2,#8] | @基址加变址寻址的索引方式<br />@前索引<br />@将r1寄存器中的数据写入到r2+8指向的内存空间 |
| mov r1,#0xFF000000		<br/>mov r2,#0x40000000		<br/>STR R1,[R2],#8 | @后索引<br />@将r1寄存器中的数据写到r2指向的内存空间,然后r2自增8 |
| mov r1,#0xFF000000		<br/>mov r2,#0x40000000		<br/>STR R1,[R2,#8]! | @自动索引<br />@将r1寄存器中的数据写入到r2+8指向的内存空间<br /> 且 r2自增8<br />==@以上三种寻址方式和索引方式同样适用LDR== |
| MOV r1,#1<br/>mov r2,#2<br/>mov r3,#3<br/>mov r4,#4<br/>mov r11,#0x40000020<br/>==stm r11,{r1-r4}== | @多寄存器内存访问指令<br/>@写入 stm                          |
| ==ldm r11,{r6-r9}==                                          | @读取 LDM<br />@将内存中以r11为起始的数据读取到r6-r9寄存器   |
| stm r11,{r1,r3,r4}<br />stm r11,{r4,r1,r3}                   | @当寄存器不连续式,适用逗号分隔                               |
| stm r11!,{r1-r4}                                             | @自动索引一样适用于多寄存器内存访问指令                      |
| MOV r1,#1<br/>mov r2,#2<br/>mov r3,#3<br/>mov r4,#4<br/>stmia r11!,{r1-r4}<br />stmib r11!,{r1-r4}	 <br/>stmda r11!,{r1-r4}	<br/>stmdb r11!,{r1-r4} | @多寄存器内存访问指令的寻址方式<br />@ia increase after后缀是默认加的, 等同于stm<br/>@ib increase before <br/>@da decrease after<br/>@db decrease before<br/>@after 则地址指向最后以一个数据<br/>@before 则地址指向最后一个数据的下一地址 |
| MOV r1,#1<br/>mov r2,#2<br/>mov r3,#3<br/>mov r4,#4<br/>mov r11,#0x40000020<br/>stmfd r11!,{r1,r4}<br/>ldmfd r11!,{r6,r9} | 入栈DB对应出栈IA<br />入栈DA对应出栈IB<br />ia,ib,da,db 容易写错<br />所以用更直接的fd(满减) fa(满增)<br /> ed(空减) ea(空增) 来表示栈, <br />这样可以统一后缀 |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |



## 作业

### D1

1.简述为什么地址总线为32bit的处理器的地址空间为4G
2.简述CPU执行指令的过程

### D2

1.简述CISC处理器与RISC处理器的本质区别是什么
2.简述什么叫做指令集
3.简述ARM处理器有哪几种工作模式以及什么时候进入哪种模式



1. ​    RISC处理器

  只保留常用的的简单指令，硬件结构简单，复杂操作一般通过简单指令的组合实现，一般指令长度固定，且多为单周期指令

  RISC处理器在功耗、体积、价格等方面有很大优势，所以在嵌入式移动终端领域应用极为广泛

CISC处理器

  不仅包含了常用指令，还包含了很多不常用的特殊指令，硬件结构复杂，指令条数较多，一般指令长度和周期都不固定

  CISC处理器在性能上有很大优势，多用于PC及服务器等领域



2.    处理器能识别的指令的集合称为指令集

  不同架构的处理器指令集不同

  指令集是处理器对开发者提供的接口



3.   ARM有8个基本的工作模式

   User 非特权模式，一般在执行上层的应用程序时ARM处于该模式

 FIQ  当一个高优先级中断产生后ARM将进入这种模式

 IRQ 当一个低优先级中断产生后ARM将进入这种模式

 SVC 当复位或执行软中断指令后ARM将进入这种模式

 Abort  当产生存取异常时ARM将进入这种模式

 Undef 当执行未定义的指令时ARM将进入这种模式

 System 使用和User模式相同寄存器集的特权模式

 Monitor 为了安全而扩展出的用于执行安全监控代码的模式

### D3

==简述ARM处理器中R13、R14、R15、CPSR寄存器的作用:==

1. R15: (PC) 程序计数器:用于存储当前取值指令的地址

R14:(LR: link register):链接寄存器

​			作用1:执行跳转指令(BL/BLX)时,LR会自动保存跳转指令下一条指令的地址,程序			需要返回时将LR的值复制					  到PC即可实现	(主动地情况)

​			作用2:产生异常时,对异常模式下的LR会自动保存被异常打断的指令的下一条指			令的地址,异常处理结束后			将LR的值复制到PC可实现程序返回	(被动的			情况)

R13:(SP:stack pointer)栈指针,用于存储当前模式下的栈顶地址

2. ​	当前程序状态寄存器CPSR。CPSR中包含条件码标志、中断禁止位、当前处理器模式以及其他状态和控制信息。在每种异常模式下都有一个对用的程序状态寄存器SPSR。当异常出现时，SPSR用于保存CPSR的状态，以便异常返回后恢复异常发生时的工作状态。

   (1)条件码标志

   N、Z、C、V，最高4位称为条件码标志。ARM的大多数指令可以条件执行的，即通过检测这些条件码标志来决定程序指令如何执行。

   各个条件码的含义如下：

   N：在结果是有符号的二进制补码情况下，如果结果为负数，则N=1；如果结果为非负数，则N=0。

   Z：如果结果为0，则Z=1;如果结果为非零，则Z=0。

   C：其设置分一下几种情况：

   ​        对于加法指令（包含比较指令CMN），如果产生进位，则C=1;否则C=0。

   ​        对于减法指令（包括比较指令CMP），如果产生借位，则C=0;否则C=1。

   ​        对于有移位操作的非法指令，C为移位操作中最后移出位的值。

   ​        对于其他指令，C通常不变。

   V：对于加减法指令，在操作数和结果是有符号的整数时，如果发生溢出，则V=1;如果无溢出发生，则V=0;对于其他指令，V通常不发生变化。

### D4

1.以IRQ为例，简述ARM处理器在正常执行程序过程中如果遇到IRQ异常会自动完成哪些动作以及处理完异常后如何返回到正常程序

1.拷贝CPSR中的内容到SPSR_<IRQ>

2.修改CPSR的值

> 				1.修改中断禁止位禁止相应的中断
> 																																
> 				2.修改模式位进入IRQ异常模式
> 																																
> 				3.修改状态位进入ARM状态(区分于Thrumb 状态, 一般都已经在ARM 状态)

3.保存返回地址到IRQ模式下的LR_<IRQ>

4.设置PC为IRQ异常向量(异常向量表对应的地址)  (1~3 都没跳转到异常处理,第4步 才跳转)

5.CPU执行处理异常的代码

6.异常返回:

		1.将SPSR_<IRQ>的值复制给CPSR,使处理器恢复之前的状态
	
		2.将LR_<IRQ>的值复制给PC,使程序跳转回被打断的地址继续执行

### D5

1.简述C语言和汇编语言的本质区别是什么

汇编语言: 

1.  每条汇编都会对应唯一对应的一条机器码,且CPU能直接识别和执行

2.  汇编中寄存器的使用,栈的分配与使用,程序的调动,参数的传递等都需要自己维护

C语言:

1.  每条C语句都要被编译器编译成若干条汇编指令才能被CPU识别和执行, 即C语句中的指令CPU不一定能直接识别,需要编译器进行"翻译"
2.  C中寄存器的使用, 栈的分配与使用, 程序的调用,参数的传递等都是编译器分配和维护的

### D6

1.编程实现使用32bit的ARM处理器实现两个128位的数据的加法运算。

注：

第一个数的bit[31:0]、bit[63:32]、bit[95:64]、bit[127:96]分别存储在R1、R2、R3、R4寄存器
第二个数的bit[31:0]、bit[63:32]、bit[95:64]、bit[127:96]分别存储在R5、R6、R7、R8寄存器
运算结果的bit[31:0]、bit[63:32]、bit[95:64]、bit[127:96]分别存储在R9、R10、R11、R12寄存器

### D7

1.使用汇编语言实现100以内的正整数之和

注：

将最终的运算结果存储在R2寄存器

LDR       R3,[PC,#0x002C]			if(a<=100)
LDR       R3,[R3]
CMP       R3,#0x00000064
BGT       0x0000002C

LDR       R2,[PC,#0x0020]			sum=sum+a
LDR       R1,[R2]
ADD       R1,R3,R1
STR       R1,[R2]

ADD       R3,R3,#0x00000001		a++
LDR       R2,[PC,#0x0008]
STR       R3,[R2]

### D8

1.以下代码为使用汇编语言模拟C语言叶子函数的调用过程，按照如下要求补全代码
注：
使用满减栈

MOV SP, #0x40000020
MIAN:
MOV R1, #3
MOV R2, #5
@调用FUNC子程序
1______________
ADD R3, R1, R2
B STOP

FUNC:
@压栈保护现场
2______________
MOV R1, #10
MOV R2, #20
SUB R3, R2, R1
@出栈恢复现场
3______________
MOV PC, LR

STOP:
B STOP

1.BL  FUNC

2.STMFD  SP!,{R1,R2}

3.LDMFD  SP!,{R1,R2}

###  D9

1.编程实现通过状态寄存器传送指令，将ARM处理器的模式修改成USER模式并将FIQ与IRQ使能
2.简述伪指令和指令的本质区别是什么

1.msr CPSR, #0x10

2.指令:是CPU可以直接执行的指令

伪指令:本身不是指令,编译器可以将其替换成若干条指令,本身不能执行,编译的时候会被替换成CPU可执行的指令

### D10

1.简述ATPCS协议的主要内容是什么

规定不同编译器的统一编译规则:

1:栈的种类: 满减栈

2:寄存器:r15 程序计数器,只能用于存储程序指针.
	  r14 链接寄存器,只能用于存储返回地址.
	 r13 栈指针,只能用于存储栈指针.
	 其余的寄存器主要用来存储局部变量

3.参数传递:3.参数传递: r0-r3	当函数的参数少于4个的时候,使用r0-r3传参,多出4的部分用栈传递	  r0 负责存储函数的返回值

### D11

1.简述交叉编译器和普通编译器的本质区别是什么
2.简述ARM处理器中的寄存器（如PC、LR、SP）与硬件控制器中的寄存器的本质区别是什么

1.在本地编译环境编译出不同运行环境下运行的可执行文件

2.寄存器没有地址,且在CPU内部,CPU可以直接调用,硬件控制器寄存器在CPU外部, 有地址,需要指向地址调用

### D12

1.使用汇编语言实现LED3闪烁实验

### D13

1.简述课程中所使用的C语言工程模板中的启动代码主要做了哪些事
2.使用C语言实现流水灯（LED2、LED3、LED4、LED5依次闪烁）

### D14

1.若使用UART协议发送一个字节的数据0x63，画出信号线上的时序图

注：8位数据位、无校验位、一位停止位

2.编程实现电脑远程控制LED状态

注：在终端上输入‘2’，LED2点亮，再次输入‘2’，LED2熄灭... ...



### D15

- 1.编程实现将WDT的递减频率设置为10000HZ，程序运行5s后开发板复位

![image-20210811093659159](F:/Typora/image-20210811093659159.png)



### D16

1.简述轮询和中断两种方式的本质区别是什么
2.使用轮询的方式检测Key3按键的状态，实现按一次按键，LED2点亮，再次按下，LED2熄灭

### D17

1.简述中断控制器的主要作用

### D18

1.使用中断的方式检测Key3按键的状态，实现按一次按键，LED2点亮，再次按下，LED2熄灭

### D19

1.编程实现通过LED状态显示当前电压范围

注：

电压在1501mv~1800mv时，LED2、LED3、LED4、LED5点亮
电压在1001mv~1500mv时，LED2、LED3、LED4点亮
电压在501mv~1000mv时，LED2、LED3点亮
电压在0mv~500mv时，LED2闪烁

### D20

1.编程实现通过LED状态显示当前电压范围，并打印产生低压警报时的时间

注：
电压在1501mv~1800mv时，LED2、LED3、LED4、LED5点亮
电压在1001mv~1500mv时，LED2、LED3、LED4点亮
电压在501mv~1000mv时，LED2、LED3点亮
电压在0mv~500mv时，LED2闪烁，且每隔一秒钟向终端打印一次当前的电压值及当前的时间

### D21

编程实现通过PWM控制蜂鸣器产生"嘀嘀"的声音

注：PWM的频率1000HZ，占空比%60

### D22

1.若使用IIC总线让从机给主机发送一个字节的数据0xA2，画出SCL和SDA上的时序图

注：从机地址为0x63

### D23

1.简述通过主机从MPU6050中的一个寄存器中读一个字节的数据的过程

2.综合项目：
实时监测开发板的放置状态，当监测到开发板水平放置时，每隔一分钟向终端上打印一次当前的时间以及开发板的状态
如：“2023-04-05 23:45:00 Status: Normal”
当监测到开发板发生倾斜时，每隔一秒钟向终端上打印一次当前的时间以及开发板的状态
如：“2023-04-05 23:45:00 Status: Warning”
同时让蜂鸣器产生“滴滴”的警报声，在警报状态下，若按下Key2按键，解除蜂鸣器的警报声
提示：
开发板水平静止放置时MPU6050的Z轴上的加速度应该等于重力加速度的值(9.8m/s2)，而其X轴和Y轴上的加速度应该等于0
当开发板发生倾斜时MPU6050的Z轴上的加速度的分量会减小，而其X轴和Y轴上的加速度分量会增大
我们可以以此来判断开发板是否发生倾斜

