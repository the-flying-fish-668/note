

# **L6--网络编程**

## 网络基础D1,2

------

### TCP/IP协议

------

#### 概念

> 32个八位二进制数 分成四个数
>
>  与TCP/IP
>
> OSI模型 七层,理想分层,未能完全实现
>
> ![](F:\Typora\clipboard-1625215388184.png)
>
> TCP/IP协议簇是internet工业标准分为四层
>
> ![img](F:\Typora\clipboard-1625215401692.png)
>
> 1. 网络接口和物理层:底层驱动,统一的接口(结构体.net_device),(OSI的数据链路层和物理层 合并)
>
> 2. 网络层:端到端的传输(IP层)
>
> 3. 传输层:数据应该交给哪一个任务处理
>
> 4. 应用层:http//  (OSI的应用层,表示层,会话层合并)
>
>    ![image-20210703084616788](F:\Typora\image-20210703084616788.png)

#### 各层典型的协议:

> ![img](F:\Typora\clipboard-1625215407642.png)

#### 1.网络接口与物理层:

(link layer)

> MAC地址:48位,全球唯一,网络设备的身份标识
>
> ARP/RAPR
>
> ARP:地址解析协议: IP地址--->MAC地址
>
> RARP:MAC地址-->IP地址
>
> PPP协议:拨号协议(电话上网)(GPRS/3G/4G)

#### 2.网络层:

(internet layer)

> IP协议:internet protocol(分为IPV4和IPV6)
>
> ICMP:internet控制管理协议 eg: ping
>
> IGMP:internet分组管理协议 广播,组播

#### 3.传输层

(transport layer)

> TCP传输控制协议:提供面向连接的,一对一的可靠数据传输协议
>
> UDP用户数据报协议:提供不可靠,无连接的尽力传输协议
>
> SCTP: TCP的增强版,实现多主机,多链路的通信

#### 4.应用层

(application layer)

> - 网页访问协议：HTTP/HTTPS
> - 邮件发送接收协议： POP3（收）/SMTP(发) 、IMAP（可接收邮件的一部分)
> - FTP:文件传输协议
> - Telnet/SSH(明文传输/加密传输): 远程登录  

#### 嵌入式相关：

> - NTP: 网络时钟协议
> - SNMP: 简单网络管理协议（实现对网络设备集中式管理）(开源的)   
> - RTP/RTSP：用传输音视频的协议（安防监控）

#### TCP/IP的通信模型:

封包和拆包

![img](F:\Typora\clipboard-1625215414487.png)





#### 以太网的数据包

![img](F:\Typora\clipboard-1625215418431.png)

​		数据包结构



数据包各部分大小

![1](F:\Typora\image-20210703092511853.png)

14 20 20 是字节

trailer 4字节(由硬件产生和校验的)

MTU:max transfer unit:以太网=1500

MSS:max segment size(最大段尺寸):网络类型,线路,系统特性 (用户数据)=1460

![](F:\Typora\clipboard-1625215426715.png)

​							各层协议的应用



TCP协议特点

> 1. 即时传输控制协议：是一种面向链接的传输层协议，它能提供高可靠性通信
> 2. （数据无误，无丢失，无失序，无重复，到达的通信）
> 3. 适用情况：对传输质量要求较高，传输大量数据的通信
> 4.    需要可靠数据传输的场合，用TCP
> 5.    MSN/QQ的用户账号登录管理相关功能采用TCP。

UDP协议的特点

> 1. 用户数据报协议，是不可靠的无连接的协议，数据发送前不需要进行连接，可以进行高效	
>
>    的数据传输
>
> 2. 适用情况：发送小尺寸数据
>
> 3.    在接受到数据给出应答较困难的网络中（比如无线网）
>
> 4.    适合于广播/组播式通信中
>
> 5.    即时通信软件的消息通常就是用UPD协议
>
> 6.    网络多媒体服务采用UPD方式进行数据传输

------

### Socket(套接字)

------



#### 特点

> 1. 是 一个编程接口(是一种网络资源)
> 2. 是一种特殊的文件描述符(对它执行IO的操作函数,read write close等
> 3. 并不仅限于TCP/IP协议
> 4. 面向连接(IP/TCP)
> 5. 无连接(UDP/IPX)

#### 分类 

> 1. 流式套接字(唯一对应TCP):提供了一个面向连接,可靠的数据服务
> 2. 数据报套接字(唯一对应着UDP):数据包以独立数据包的的形式被发送
> 3. 原始套接字(对应多个协议):可以对较低层次的协议直接访问(如IP,ICMP)(跳过了传输层)

------

### IP地址

------



#### 分类

> IPV4:采用32位的整数来表示
>
> > 表示形式:2种
> >
> > > 点分形式:192.168.7.246
> > >
> > > 32位整数:
> >
> > 特殊IP地址:
> >
> > > 局域网ip:
> > >
> > > > 192.XXX.XXX.XXX 
> > > >
> > > > 10.XXX.XXX.XXX
> > >
> > > 广播ip:
> > >
> > > > XXX.XXX.XXX.255
> > > >
> > > > 255.255.255.255(全网广播)
> > >
> > > 组播IP:
> > >
> > > 224.XXX.XXX.XXX~239.XXX.XXX.XXX
>
> IPV6:采用128位的整数来表示
>
> > local IP(本地IP)
> >
> > roam IP(漫游IP)
>
> ==子网掩码???==

------

### 端口号

------



> 16位数字(1-65535)
>
> 禁用端口: 1~1023(FTP:21,SSH:22,HTTP:80,HTTPS:469) 不能用
>
> 保留端口:1024~5000 不建议用
>
> TCP端口和UDP端口是相互独立的,互不影响
>
> 网络里面的通信是由IP地址+端口号 来决定

------

### 字节序

------



#### 定义:

> 不同类型CPU的主机中,内存存储多字节整数序列有两种方法,称为主机字节序(HBO)
>
> (如果CPU访问的是字符串,则不存在大小端的问题)
>
> 小端序:低序字节存储在低地址 ==X86,ARM==
>
> 大端序:高序字节存储在低地址  ==powerpc/mipc, ARM作为路由器时==
>
> ![image-20210702141234913](F:\Typora\image-20210702141234913.png)



#### 主机字节序到网络字节序

> `•u_long htonl (u_long hostlong);`  (host to network long ==4字节==)
>
> `•u_short htons (u_short short);`     (host to network short ==2字节==)

#### 网络字节序到主机字节序

> 把给定系统所采用的字节序称为主机字节序。为了避免不同类别主机之间在数据交换时由于对于字节序的不同而导致的差错，引入了网络字节序
>
> `•u_long ntohl (u_long hostlong);`
>
> `•u_short ntohs (u_short short);`

#### IP地址的转换

------



##### 第一种函数

> `in_addr_t inet_addr(const char *cp);`
>
> cp:  点分形式的IP地址，结果是32位整数（内部包含了字节序的转换，默认是网络字节序的模式）
> 特点： 
>
> 1.==仅适应于IPV4==
>
> 2.当出错时，返回-1
>
> 3.此函数不能用于255.255.255.255的转换

##### 第二种函数

> ```c
> `inet_pton()/inet_ntop()`
> 	`#include<arpa/inet.h>`
> 
> `int inet_pton(int af,const char *src,void *dst);`
> ```
>
> 特点：    1.==适应于IPV4和IPV6==
> 				2.能正确的处理255.255.255.255的转换问题
>
> 参数：
>
> ```
>   1. af: 地址协议族（AF_INET或AF_INET6）
>   2. src:是一个指针（填写点分形式的IP地址[主要指IPV4])
>   3. dst:  转换的结果给到dst
> ```
>
> return value:
>
> **RETURN VALUE
>
> **    inet_pton() returns  1 on success (network address was successfully con‐
>     verted). 0 is  returned if src does not contain a character string representing a valid  network address in the specified address family. If af does not contain a valid  address family, -1 is returned and errno is set to EAFNOSUPPORT.

##### 第三种函数

> inet_ntop:把IPV4/IPV6的网络字节序的地址变成本地的字符串形式的地址
>
> ```c
> #include<arpa/inet.h>
> 
> const char*inet_ntop(int af,const void  * src,  char *dst, socklen_t size);
> ```
>
> 特点:
>
> 1.能适用于IPV4/IPV6
>
> 2.能正确处理-1的转换问题
>
> 参数:
>
> af:地址协议族(AF_INET或AF_INET6)
>
> src是一个指针(32位网络字节序的IP地址)
>
> dst:输出结果为点分形式的输出地址[主要指IPV4]
>
> 返回值:
>
> on success, inet_ntop() return a non-NULL pointer to dst, NULL is error, with error set to indicate thr erro



## TCP编程D3

![22](F:\Typora\image-20210703094946823.png)

### 五个函数

> socket()
>
> bind()
>
> listen()
>
> accept()
>
> connect()

#### socket() 插口

> ```c
> #include<sys/types.h>
> 
> #include<sys/socket.h>
> 
> int socket*(int domain, int type, int protocol);
> ```
>
> 参数：
>
> 1.domain: (域)
>  ==AF_INET==      IPv4 Internet protocols      ip(7)
>  ==AF_INET6==     IPv6 Internet  protocols     ipv6(7)
>   AF_UNIX, ==AF_LOCAL==   Local communication       unix(7)(本地通信)
>   AF_NETLINK     Kernel user  interface device   netlink(7)(内核和用户的通信)
>   AF_PACKET      Low level packet  interface    packet(7)(原始套接字通信)
>
>   type:
>   SOCK_STREAM: 流式套接字 唯一对应于TCP
>   SOCK_DGRAM： 数据报套接字，唯一对应着UDP
>   SOCK_RAW： 原始套接字
>   3.protocol: 一般填0，原始套接字编程时需填充
>
> 返回值：
>  RETURN VALUE
>     On success, a file descriptor for the new  socket is returned. On
>     error, -1 is returned, and errno is set  appropriately.
>
>    成功时返回文件描述符，出错时返回为-1

#### bind() 绑定

> ```c
> #include<sys/types.h>
> 
> #include<sys/socket.h>
> 
> int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
> ```
>
> 参数:
>
> sockfd: 通过socket()函数拿到的fd  ==(File Discriptor)==
>
> addr: struct sockaddr的结构体变量的地址 
> addrlen:  地址长度 
>
> 通用结构体
>
> ```c
> struct sockaddr{
> 
> sa_family_t sa_family;
> 
> char sa_data[14];
> 
> };
> ```
>
> 基于internet通信的结构体
>
> ```c
> struct sockaddr_in{
> 
> sa_family_t   sin_family;  //address family: AF_INET;IP类型
> 
> in_port_t    sin_port;  //port in network order 端口号
> 
> struct in_addr   sin_addr;   //internet address IP号
> 
> };
> 
> struct in_addr{			//internet adress
> 
> unit32_t    s_addr		//adress in network byte order 
> 
> };
> ```
>
> 返回值
>
> RETURN VALUE
>     On success, zero is returned. On error, -1 is returned,  and errno is set appropriately.
>
> 示例代码：
>
> ![image-20210703132734998](F:\Typora\image-20210703132734998.png)
>
>  如果是IPV6的编程，要使用struct sockaddr_in6结构体（详细情况请参考man 7 ipv6）,通常更通用的方法可以通过struct  sockaddr_storage来编程
>
> 
>
> end

#### listen()接听

> 把主动套接字变成被动套接字
>
> ```c
> #include <sys/types.h>
> 
> #include<sys/socket.h>
> 
> int listen(int sockfd,int backlog);
> 
> ```
>
> 参数:   
>
> sockfd: 通过socket()函数拿到的fd
> backlog： 同时允许几路客户端和服务器进行正在连接的过程（正在三次握手）
>
> 一般填5， 测试得知,ARM最大为8
>
> 内核中服务器的套接字fd会维护2个链表：
>               1.  正在三次握手的的客户端链表(数量=2*backlog+1)
>               2.  已经建立好连接的客户端链表（已经完成３次握手分配好了newfd）
>
> 返回值：
>
>    RETURN VALUE
>     On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.
>
> end

#### accpet()接受

> 阻塞等待客户端连接请求
>
> ```c
> #include<sys/types.h>
> 
> #include<sys/socket.h>
> 
> int accept(int sockfd,struct sockaddr *addr, socklen_t *addrlen);
> ```
>
> 参数:
>
> sockfd:经过前面socket()创建并通过bind(),listen()设置过的fd,addr和addrlen:
>
> 获取连接过来的客户的信息
>
> 返回值:
>
> RETURN VALUE
>     On success, these system calls return a nonnegative  integer that is a descriptor for the accepted socket. On
>     error, -1 is  returned, and errno is set appropriately.
>
> ​     成功时返回已经建立好连接的新的newfd
>
> 示例代码
>
> ![image-20210703163558630](F:\Typora\image-20210703163558630.png)
>
> 
>
> end

#### connect()连接

> 客户端的连接函数
>
> ```c
> #incliude<sys/types.h>
> 
> #include<sys/socket.h>
> 
> int connect(int sockfd, const struct sockaddr *addr, socklen_t  addlen);
> 
> ```
>
> 参数
>
> sockfd: 通过socket()函数拿到的fd
>   addr: struct sockaddr的结构体变量的地址 
>   addrlen:  地址长度 
>
> 返回值：
>  RETURN VALUE
>     If the connection or binding succeeds, zero is  returned. On error, -1
>     is returned, and errno is set appropriately.
>
> end

### server完整代码

头文件

> ```c
> #ifndef __MAKEU_NET_H__
> #define __MAKEU_NET_H__
> 
> #include <stdio.h>
> #include <string.h>
> #include <unistd.h>
> #include <errno.h>
> #include <stdlib.h>
> #include <strings.h>
> #include <sys/types.h>			/* See NOTES */
> #include <sys/socket.h>
> #include <netinet/in.h>
> #include <netinet/ip.h>			/* superset of previous */
> 
> #define SERV_PORT 5001
> #define SERV_IP_ADDR "192.168.7.246"
> #define BACKLOG 5
> 
> #define QUIT_STR "quit"
> 
> #endif
> ```

服务器change

> ```c
> #include "net.h"
> 
> int main (void)
> {
> 
> 	int fd = -1;
> 	struct sockaddr_in sin;
> 
> 	/* 1. 创建socket fd */
> 	if ((fd = socket (AF_INET, SOCK_STREAM, 0)) < 0) {
> 		perror ("socket");
> 		exit (1);
> 	}
> 
> 	/*2. 绑定 */
> 	/*2.1 填充struct sockaddr_in结构体变量 */
> 	bzero (&sin, sizeof (sin));
> 	sin.sin_family = AF_INET;
> 	sin.sin_port = htons (SERV_PORT);	//网络字节序的端口号
> 
> 	/*优 */
> 
> #if 1
> 	sin.sin_addr.s_addr = htonl (INADDR_ANY);
> #else
> 	if (inet_pton (AF_INET, SERV_IP_ADDR, (void *) &sin.sin_addr) != 1) {
> 		perror ("inet_pton");
> 		exit (1);
> 	}
> #endif
> 	/*2.2 绑定 */
> 	if (bind (fd, (struct sockaddr *) &sin, sizeof (sin)) < 0) {
> 		perror ("bind");
> 		exit (1);
> 	}
> 
> 	/*3. 调用listen()把主动套接字变成被动套接字 */
> 	if (listen (fd, BACKLOG) < 0) {
> 		perror ("listen");
> 		exit (1);
> 	}
> 	printf ("Server starting....OK!\n");
> 	int newfd = -1;
> 	/*4. 阻塞等待客户端连接请求 */
> 
> #if 0
> 	newfd = accept (fd, NULL, NULL);
> 	if (newfd < 0) {
> 		perror ("accept");
> 		exit (1);
> 	}
> #else
> 	/*优化2：通过程序获取刚建立连接的socket的客户端的IP地址和端口号 */
> 	struct sockaddr_in cin;
> 	socklen_t addrlen = sizeof (cin);
> 	if ((newfd = accept (fd, (struct sockaddr *) &cin, &addrlen)) < 0) {
> 		perror ("accept");
> 		exit (1);
> 	}
> 
> 	char ipv4_addr[16];
> 	if (!inet_ntop (AF_INET, (void *) &cin.sin_addr, ipv4_addr, sizeof (cin))) {
> 		perror ("inet_ntop");
> 		exit (1);
> 	}
> 
> 	printf ("Clinet(%s:%d) is connected!\n", ipv4_addr, ntohs (cin.sin_port));
> 
> #endif
> 	/*5. 读写 */
> 	//..和newfd进行数据读写
> 	int ret = -1;
> 	char buf[BUFSIZ];
> 	while (1) {
> 		bzero (buf, BUFSIZ);
> 		do {
> 			ret = read (newfd, buf, BUFSIZ - 1);
> 		} while (ret < 0 && EINTR == errno);
> 		if (ret < 0) {
> 
> 			perror ("read");
> 			exit (1);
> 		}
> 		if (!ret) {				//对方已经关闭
> 			break;
> 		}
> 		printf ("Receive data: %s\n", buf);
> 
> 		if (!strncasecmp (buf, QUIT_STR, strlen (QUIT_STR))) {	//用户输入了quit字符
> 			printf ("Client is exiting!\n");
> 			break;
> 		}
> 	}
> 	close (newfd);
> 
> 	close (fd);
> 	return 0;
> 
> }
> ```



### client完整代码

客户端

> ```c
> #include "net.h"
> 
> int main (void)
> {
> 	int fd = -1;
> 	struct sockaddr_in sin;
> 	/* 1. 创建socket fd */
> 	if ((fd = socket (AF_INET, SOCK_STREAM, 0)) < 0) {
> 		perror ("socket");
> 		exit (1);
> 	}
> 	/*2.连接服务器 */
> 
> /*2.1 填充struct sockaddr_in结构体变量 */
> bzero (&sin, sizeof (sin));
> 
> sin.sin_family = AF_INET;
> sin.sin_port = htons (SERV_PORT);	//网络字节序的端口号
> 
> #if 0
> 	sin.sin_addr.s_addr = inet_addr (SERV_IP_ADDR);
> #else
> 	if (inet_pton (AF_INET, SERV_IP_ADDR, (void *) &sin.sin_addr) != 1) {
> 		perror ("inet_pton");
> 		exit (1);
> 	}
> #endif
> 
> if (connect (fd, (struct sockaddr *) &sin, sizeof (sin)) < 0) {
> 	perror ("connect");
> 	exit (1);
> }
> 
> printf ("Client staring...OK!\n");
> /*3. 读写数据 */
> char buf[BUFSIZ];
> int ret = -1;
> while (1) {
> 	bzero (buf, BUFSIZ);
> 	if (fgets (buf, BUFSIZ - 1, stdin) == NULL) {
> 		continue;
> 	}
> 	do {
> 		ret = write (fd, buf, strlen (buf));
> 	} while (ret < 0 && EINTR == errno);
> 
> ​	if (!strncasecmp (buf, QUIT_STR, strlen (QUIT_STR))) {	//用户输入了quit字符
> ​		printf ("Client is exiting!\n");
> ​		break;
> ​	}
> }
> 
> /*4.关闭套接字 */
> close (fd);
> 
> }
> ```

ifconfig查看网卡配置(包括实际网卡和虚拟网卡)

![image-20210703183533559](F:\Typora\image-20210703183533559.png)

sudo ifconfig eth0:0 139.237.45.87 up

虚拟网卡命令

IPV4 地址 由点分式转化成 字符串型, 需要16位 长度

### 代码优化

1.ADDR_ANY (只要端口一样,网络类型是TCP,则不区别服务器的哪一个网卡地址,都能传送数据 )

2.使服务器获取客户端的IP地址,

## 并发服务器D4

### 并发服务器多线

![image-20210707090945738](F:\Typora\image-20210707090945738.png)





### 并发服务器多进



## UDP编程D5

### 网络编程API扩展及UDP编程API

UDP会丢包, TCP不会丢包(正常情况下)

UDP编程接口结构图

![image-20210707094001507](F:\Typora\image-20210707094001507.png)



write()/send()

> write(fd标识    buf地址在哪   count长度)
>
> send(fd    buf    len   flags) 
>
> send 比write多一个参数 flags  
>
> flags 介绍
>
> > 1. 可以填0,此时send和write作用一样  
> > 2. MSG_DONTWAIT: 非阻塞标识
> > 3. MSG_OOB: OOB->out of band (非常规状况)  用于发送TCP类型的带外数据



read()/recv()

> read(fd, buf, count)
>
> recv(fd, buf,len, flags) 
>
> flags 介绍
>
> > 1. 可以填0,此时send和write作用一样  
> > 2. MSG_DONTWAIT: 非阻塞标识
> > 3. MSG_OOB: OOB->out of band (非常规状况)  用于发送TCP类型的带外数据
> > 4. MSG_PEEK: 正常是读+取 buf的内容,但是加了PEEK关键字之后, 则只读不取,

send()/sendto()

> send(fd, buf, len, flags)
>
> sendto(fd, buf, len, flags, dest_addr地址和端口, addrlen地址长度)
>
> ​	(目的ip和端口)

recv()/recvfrom()

> recv(fd, buf, len, flags)
>
> recvfrom(fd, buf, len, flags,src_addr, addrlen)
>
> ​	(发送方IP和端口)

UDP应用场景:

实时的视频音频传输,DNS的域名解析包







### UDP编程

[net.h](源文件link\net.h)  
[UDP-client.c](源文件link\UDP-client.c) 
[UDP-server.c](源文件link\UDP-server.c) 

UDP接口结构图简图



![image-20210707103524471](F:\Typora\image-20210707103524471.png)

## IO多路复用D6

### IO模型以及多路复用基本原理

#### 为什么使用多路复用I/O

> 1. 应用程序中同时处理多路输入输出流,若采用阻塞模式,将达不到预期目的
> 2. 若采用非阻塞模式,对多个输入进行轮询,又会占用太多CPU资源
> 3. 若设置多个进程,分别处理一条数据通路,将产生进程间同步与通信问题,程序更复杂.
> 4. I/O多路复用既能解决问题,又不会占用太多资源

#### 4种I/O模型

##### 阻塞I/O

> 最常用的,缺省状态下的就是阻塞模式
>
> 典型函数:
>
> TCP协议中
>
>  read()套接字的接收缓冲区中没有数据可读, read就会一直阻塞
>
> write()写入缓冲区满的时候,会发生阻塞
>
> UDP协议中执行==写操作==不存在阻塞
>
> 
>
> end

##### 非阻塞I/O

> 示意图:防止进程阻塞在I/O上,  轮询模式,比较浪费CPU资源
>
> ![image-20210708094001396](F:\Typora\image-20210708094001396.png)
>
> 非阻塞的函数实现
>
> 1.fcntl()
>
> ```c
> 	int fcntl(int fd,int cmd,long arg);
> 
> 	int flag;
> 	flag = fcntl(sockfd, F_GETFL,0);
> 
> 	flag |= )_NONBLOCK;
> 
> 	fcntl(sockfd, F_SETFL, flag);
> ```
>
> 2.ioctl()
>
> ```c
> 	int b_on = 1;
> 
> 	ioctl(sock_fd, FIONBIO, &b_on);
> ```
>
> end



##### 多路复用I/O

> 允许同时对多个I/O进行控制
>
> 基本常识
>
> > 1. 多路复用针对不止套接字fd,也针对普通的文件描述符fd
> >
> > 2. Linux中每个进程默认情况下,最多可以打开1 024个文件,最多有==1024==个文件描述符
> >
> > 3. 文件描述符特点
> >
> >    ​	1.非负整数
> >
> >    ​	2.从最小可用数字来分配
> >
> >    ​    3.每个进程启动时默认打开 0,1,2 三个文件描述符
>
> 方法思路
>
> > 1.先构造一张有关描述符的表, 然后调用一个函数,当这些文件描述符中的一个或多个已经准备好进行I/O时, 函数才返回.
> >
> > 2.函数返回时,告诉进程哪个描述符已就绪,可以进行I/O操作.
>
> 函数实现select()/poll()
>
> > 1. 把I/O文件描述符加入到集合中 fd_set 
> > 2. 调用select()/poll() 函数监控集合fd_set中的文件描述符(阻塞等待集合中的一个或多个文件描述符有数据)
> > 3. 当有数据时退出select()/poll()
> > 4. 以次判断哪个文件描述符有数据,
> > 5. 依次处理有数据的文件描述符的数据
> >
> > 
> >
> > end
>
> maxfd   
>
> end



##### 信号驱动I/O

一种异步通信模型

SIGIO 信号处理

### select模型

1.fd_set reset 集合相关操作函数

> -void FD_ZERO(fd_set  *fdset)     清零集合
>
> -void FD_SET(int fd,fd_set *fdset)	把某个fd加入到集合里
>
> -void FD_CLR(int fd,fd_set *fdset)	从集合中清除某个fd
>
> -int FD_ISSET(int fd,fd_set *fdset)	判断某个fd是否在集合中

2.select()

> ```c
> int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds,struct timeval *timeout);
> ```
>
> 是一个阻塞函数   参数(maxfd+1, 读集合,写集合,异常集合,超时设定)
>
> 一般:填读集合,写集合填 NULL,异常集合--带外数据,一般为NULL,秒或微秒
>
> ==select()退出后,集合表示有数据的集合,==
>
> ```c
> if(FD_ISSET(fd,rset)){}
> ```
>
> 若监听套接字上有数据,则有新的客户端连接,则accept()
>
> 若是已经建立连接的套接字上有数据,则去read()数据
>
> ![image-20210708144458097](F:\Typora\image-20210708144458097.png)
>
> end

### 客户端select的实现

 

### 服务器端select的实现



## TCP/IP协议原理D7

### wireshark抓包工具使用

下载wireshark 使用wireshark

### eth_ip头原理

 以太网包头 (物理链路层)

> 一共 14字节
>
>  MAC地址,全球唯一 48位  6字节  *2=12 字节
>
> 目的MAC地址 6 	源MAC地址 6  包的类型 2

IP包头(网络层)

> ![image-20210710191832229](F:\Typora\image-20210710191832229.png)
>
> 
>
> ![image-20210709191337399](F:\Typora\image-20210709191337399.png)

TCP包头

> TCP是一种面向连接的可靠的数据传输(传输层)(16位端口)(确认重发机制)
>
> TCP把所有的要发送的数据进行编号
>
> 发送时从当前数据位置,发送window大小的数据
>
> ![image-20210710170713244](F:\Typora\image-20210710170713244.png)
>
> 
>
> ![image-20210710191556929](F:\Typora\image-20210710191556929.png)
>
> end



### TCP包头-确认重发机制



### TCP三次,四次握手

三次握手和四次握手

![image-20210710184721485](F:\Typora\image-20210710184721485.png)

注意点:

1.一定区分标记客户端和服务器

2.三次握手的发起必须是由客户端发起(四次握手 server和client都可以)

3.SYN, ACK, FIN 等标志符号应该写上

4.四次握手的ACK 和FIN 有时候会一个包发送,所以只能抓到三次交互



## 网络扩展编程D8D9

### 域名解析

网络信息检索

> –gethostname()　获得主机名
>
> –getpeername()　获得与套接口相连的远程协议地址
>
> –getsockname()　获得本地套接口协议地址
>
> ==–gethostbyname()==　根据主机名取得主机信息 àendhostent()
>
> –
>
> –gethostbyaddr()　根据主机地址取得主机信息
>
> –getprotobyname()　根据协议名取得主机协议信息
>
> –getprotobynumber()　根据协议号取得主机协议信息
>
> –getservbyname()　根据服务名取得相关服务信息
>
> –getservbyport()　根据端口号取得相关服务信息

域名转换成IP地址  就叫 域名解析    

> 函数  gethostbyname()
>
> #include <netdb.h>
>
> extern int h_errno;
>
> struct hostent *gethostbyname(const char *name); //name填写域名或者IP地址
>
> return value: 
>
> 正确时返回hostent struct  pointer(结构体指针), 错误时返回 空
>
> 只能用于IPV4.
>
> IPV6 用的是getaddrinfo()   (与协议无关, IPV4 IPV6 都能用)
>
> hostent结构体
>
> ```c
> struct hostent{
> 
> ​	char *h_name; 				//offical name of host;
> 
> ​	char **h_aliases;			//alias list *
> 
> ​	int h_addrtypes;			//host adress type
> 
> ​	int h_length;				//length of adress
> 
> ​	char **h_addr_list;			//list of addresses
> 
> }
> #define h_addr h_addr_list[0] 	//for backward compatibility
> ```
>
> h_addr_list: an array of pointers to network addresses for the host(32位网络字节序的主机网络地址,多个),terminated by a NULL pointer.
>
> 
>
> end









### 网络属性设置

socketopt()

```c
#include<sys/types.h>

#include<sys/socket.h>

int getsockopt(int sockfd, int level, int optname,void * optvalue,socklen_t *optlen);

int setsocketopt(int sockfd, int level,int optname, const void * optval, socklen_t,socklen);
```

参数: 

level 

> 指定控制套接字的层次, 可取三种值
>
> SOL_SOCKET: 通用套接字选项(应用层)
>
> IPROTO_TCP: TCP选项 (传输层)
>
> IPPROTO_IP: IP选项	(网络层)

optname

> ![image-20210712110110570](F:/Typora/image-20210712110110570.png)





### 网络超时优化

超时检测

网络超时优化

method1

> 设置socket属性 SO_RCVTIMEO
>
> 参考代码:
>
> ```c
> struct timeval tv;
> 
> tv.tv_sec = 5;
> 
> tv.tv_usec = 0;
> 
> setsockopt(sockfd, SOL_SOCKET, SO_RCVTOMEO, &tv,sizeof(tv)); //设置接收超时
> 
> recv()/recvfrom()  //从socket读取数据
> ```
>
> 

method2

> 用select检测socket是否ready
>
>  参考代码如下
>
> ```c
> struct fd_set rdfs;
> 
> struct timeval tv{5,0}; //设置时间
> 
> ​	FD_ZERO(&rdfs);
> 
> ​	FD_SET(sockfd, &rdfs);
> 
> ​	if(select(sockfd+1, &rdfs, NULL, &tv)>0)	//socket 就绪
> 
> ​	{ 	recv()/recvfrom()}		//从socket读取数据
> ```
>
> 

method3

> 设置定时器(timer), 捕捉SIGALRM信号
>
> 参考代码如下
>
> ```c
> void handler(int signo)
> 
> struct sigaction act;
> 
> sigaction(SIGALRM,NULL,&act);
> 
> act.sa_handler = handler;
> 
> act.sa_flags &= ~SA_RESTART;  (~ 作用是取反 )
> 
> sigaction(SIGALRM, &act,NULL);
> 
> alarm(5);
> 
> if(recv(,,,)<0)...
> 
> 
> ```

心跳检测

method1:

数据交互双方隔一段时间,一方发送一点数据到对方,另一方给出特定应答,如果超过设定时间则认为断连.

method2:

![image-20210712170926975](F:/Typora/image-20210712170926975.png)

### 广播编程

一对多--UDP

> 广播发送:
>
> 创建用户数据报套接字
>
> setsocket设置套接字属性(缺省状态下不允许广播数据包,需要设置)
>
> 接收方地址指定为广播地址
>
> 指定端口信息
>
> 发送数据包

> 广播接收:
>
> 创建用户数据报套接字, 绑定本机IP地址和端口(必须和发送方指定的端口相同)
>
> 等待接收数据

### 多播

又称为组播, 是一种折中的方式,只有加入到某个多播组的主机才能收到数据

一个人发送,加入到多播组的人接收数据

也是基于UDP编程



### unix域套接字

用于 linux进程间通信

本地通信分类六种

> 进程间的数据共享
>
> 1..管道	2.消息队列	3.共享内存	4.unix域套接字
>
> > 易用性: 消息队列>unix域套接字>管道>共享内存
> >
> > 效率:	共享内存>unix域套接字>管道>消息队列
> >
> > 常用:	共享内存, 域套接字
>
> 异步通信
>
> 5.信号
>
> 同步和互斥
>
> 6.信号量











## 作业

### D1

1.请说出网络的OSI七层模型名称

\2. 请说出TCP/IP的四层分层中 每层的名称，每层的作用，每层至少说出2种典型协议

3.画出TCP/IP协议中以太网包的组成和各部分的大小:

4.请问交换机和路由器的实现原理分别是什么？分别在哪个层次上面实现的？（自己扩展

------

### D2

\1. 请选择以下不是socket类型的是：
A). 流式套接字 B). 数据报套接字C). 网络套接字D). 原始套接字

\2. socket是一种特殊的文件描述，以下文件IO操作函数不适应于socket的是：
A). open() B).close() C). read() D).write()

\3. 以下不是合法的IPV4的地址是：
A). 192.168.0.14 B). 10.87.384.31 C).255.255.255.255 D). 127.0.0.1

\4. 以下关于IP地址说法，错误的是：

A). IP可以采用数字表示，比如0xe80e0832就可以表示一个IP地址
B). IPV6的提出主要目的是解决IPV4的IP地址枯竭的问题
C). 234.76.10.1是一个合法的广播地址
D). ::1是一个合法的IP地址

\5. 以下关于端口号的说法，错误的是：

A). 端口是一个16位的数字，主要用于系统区分不同的网络数据该由那个任务来处
B).为避免冲突，TCP和UDP端口不能同时使用同一端口
C).网络数据是由IP地址和端口以及套接字类型决定的
D).用户编程不可使用1024以下的端口

\6. 请简要总结网络字节序形成的原因，以及网络编程中对应的处理方法。

答案

1.C
2.A
3.B
4.C
5.B
6.把给定系统所采用的字节序称为主机字节序。为了避免不同类别主机之间在数据交换时由于对于字节序的不同而导致的差错，引入了网络字节序
主机字节序到网络字节序
u_long htonl (u_long hostlong);
u_short htons (u_short short);

网络字节序到主机字节序
u_long ntohl (u_long hostlong);
u_short ntohs (u_short short);

### D3

\1. 已知TCP编程中已经通过socket()函数获取到了套接字fd, 请使用绑定函数bind()函数对fd进行”绑定”
附：bind()函数的原型如下：
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

\2. 请编写基于TCP协议的简单客户端和服务器交互的代码。
（作业要求：做作业的时候不要再翻看视频上的教程，对函数理解不明白的全部通过man手册去查看，
使用makefile编译，然后将测试的记录和结果添加到readme.txt文件中提交上来，代码实现完成测试通过后
再提交作业，网络部分学习不写代码不测试看不出问题的，良好的习惯帮助你们快速成长。）



答案

1.	bzero (&sin, sizeof (sin));
	sin.sin_family = AF_INET;
	sin.sin_port = htons (SERV_PORT);	

#if 1
	sin.sin_addr.s_addr = htonl (INADDR_ANY);
#else
	if (inet_pton (AF_INET, SERV_IP_ADDR, (void *) &sin.sin_addr) != 1) {
		perror ("inet_pton");
		exit (1);
	}
#endif
	
	if (bind (fd, (struct sockaddr *) &sin, sizeof (sin)) < 0) {
		perror ("bind");
		exit (1);
	}

### D4

\1. 阅读以下程序，完成下面的a-c题：

┋
listenfd = socket(…);
bind(listenfd,…);
listen(listenfd,…);

for ( ; ; ) {
connfd = accept(listenfd, …);
if (( pid = fork( )) == 0) {
recv(connfd,…);
send(connfd,…);
}
else
close(connfd);
}
根据上面的程序，对以下说法判断对错
a. 这是一个并发服务器（对 ）
b. 在任何时候，该服务器只能处理一个客户端的请求（ 错）
c. 随着服务器端接受越来越多的请求，connfd的值变得越来越大（对 ）

2.请用多线程编写TCP服务器和客户端通信的代码，功能：一个服务器能处理多个客户端的请求：
（作业要求：做作业的时候不要再翻看视频上的教程，对函数理解不明白的全部通过man手册去查看，
自己思考框架，使用makefile编译，然后将测试的记录和结果添加到readme.txt文件中提交上来，代码实现完成测试通过后
再提交作业，网络部分学习不写代码不测试看不出问题的，良好的习惯帮助你们快速成长。）

### D5

\1. 简述tcp和udp的特点，以及tcp中有序传输的原理?
\2. 请编写支持多客户端的UDP服务器和客户端通信的代码
（作业要求：做作业的时候不要再翻看视频上的教程，对函数理解不明白的全部通过man手册去查看，
自己思考框架，使用makefile编译，然后将测试的记录和结果添加到readme.txt文件中提交上来，代码实现完成测试通过后
再提交作业，网络部分学习不写代码不测试看不出问题的，良好的习惯帮助你们快速成长。）

答案
        ==TCP==

1. 即时传输控制协议：是一种面向链接的传输层协议，它能提供高可靠性通信

2. （数据无误，无丢失，无失序，无重复，到达的通信）

3. 适用情况：对传输质量要求较高，传输大量数据的通信

4. 需要可靠数据传输的场合，用TCP

5. MSN/QQ的用户账号登录管理相关功能采用TCP。

  ==UDP==

6. 用户数据报协议，是不可靠的无连接的协议，数据发送前不需要进行连接，可以进行高效率		
   的数据传输

7. 适用情况：发送小尺寸数据

8. 在接受到数据给出应答较困难的网络中（比如无线网）

9. 适合于广播/组播式通信中

10. 即时通信软件的消息通常就是用UPD协议

11. 网络多媒体服务采用UPD方式进行数据传输

==TCP顺序传输的原理==
（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区； 

（2）并为每个已发送的数据包启动一个超时定时器； 

（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区; 

（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。

（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。

### 	D6

1.编写基于tcp模型的IO多路复用（select）程序，在服务器端采用select来实现客户端的多路并发，
当客户端输入为quit时当前客户端退出。
（作业要求：做作业的时候不要再翻看视频上的教程，对函数理解不明白的全部通过man手册去查看，
自己思考框架，使用makefile编译，然后将测试的记录和结果添加到readme.txt文件中提交上来，代码实现完成测试通过后
再提交作业，网络部分学习不写代码不测试看不出问题的，良好的习惯帮助你们快速成长。）

2（经典面试题）说下select和epoll的区别；
根据以下链接，整理出epoll的原理和优缺点，写一个测试代码；
参考直播： http://www.makeru.com.cn/live/5413_1937.html
参考博客： https://segmentfault.com/a/1190000003063859
参考播客： http://blog.csdn.net/davidsguo008/article/details/73556811
（注：poll现在用的比较少了，如果感兴趣，可以自己了解下）

参考：
你可能会用到的函数如下：
int socket(int domain, int type, int protocol);
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int select(int nfds, fd_set *readfds, fd_set *writefds,
fd_set *exceptfds, struct timeval *timeval);
void FD_CLR(int fd, fd_set *set);
int FD_ISSET(int fd, fd_set *set);
void FD_SET(int fd, fd_set *set);
void FD_ZERO(fd_set *set);

struct sockaddr {
sa_family_t sin_family;
char sa_data[14];
};
struct sockaddr_in {
u_short sin_family;
u_short sin_port;
struct in_addr sin_addr;
char sin_zero[8];
};
struct in_addr {
in_addr_t s_addr; // unint32_t
};

### D7

\1. 请解释TCP的可靠传输原理
\2. 请叙述在client/server模型中，TCP的三次握手和四次握手过程

![image-20210710194455176](F:/Typora/image-20210710194455176.png)

### D8

1.请编写简要的DNS的解析代码

\2. 请编写简要套接字编程中，用setsockopt()函数实现允许地址快速重用，以及设置接收10秒超时的相关服务器和客户端代码
（作业要求：做作业的时候不要再翻看视频上的教程，对函数理解不明白的全部通过man手册去查看，
自己思考框架，使用makefile编译，然后将测试的记录和结果添加到readme.txt文件中提交上来，代码实现完成测试通过后
再提交作业，网络部分学习不写代码不测试看不出问题的，良好的习惯帮助你们快速成长。）
3.请解释网络编程中的“心跳检测”概念和给出实现方法

### D9

1.【不定项选择】 以下功能用到UDP协议实现的是 （AB ）
A. 广播
B. 组播
C.带外数据
D.ping

2.用于同一主机内部进程间通信的socket应使用的地址族是（D ）
A. AF_INET
B. AF_NETLINK
C. AF_PACKET
D. AF_UNIX或AF_LOCAL

\3. 请编写组播通信的服务器和客户端的代码：
（作业要求：做作业的时候不要再翻看视频上的教程，对函数理解不明白的全部通过man手册去查看，
自己思考框架，使用makefile编译，然后将测试的记录和结果添加到readme.txt文件中提交上来，代码实现完成测试通过后
再提交作业，网络部分学习不写代码不测试看不出问题的，良好的习惯帮助你们快速成长。）

## 扩展:OSI七层介绍

[编辑](javascript:;)[ 语音](javascript:;)

根据建议X.200，OSI将计算机网络体系结构划分为以下七层，标有1～7，第1层在底部。 现“OSI/RM”是[英文](https://baike.baidu.com/item/英文)“Open Systems Interconnection Reference Model”的缩写。

### 第7层 应用层

主条目：[应用层](https://baike.baidu.com/item/应用层)

应用层（Application Layer）提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如: HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。

### 第6层 表达层

主条目：表达层

表达层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。

### 第5层 会话层

主条目：[会话层](https://baike.baidu.com/item/会话层)

会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。

### 第4层 传输层

主条目：[传输层](https://baike.baidu.com/item/传输层)

传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。

### 第3层 网络层

主条目：[网络层](https://baike.baidu.com/item/网络层)

网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。例如:[互联网协议](https://baike.baidu.com/item/互联网协议/6492810)（IP）等。

### 第2层 数据链路层

主条目：[数据链路层](https://baike.baidu.com/item/数据链路层)

数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、[无线局域网](https://baike.baidu.com/item/无线局域网/176200)（Wi-Fi）和通用分组无线服务（GPRS）等。

分为两个子层：[逻辑链路控制](https://baike.baidu.com/item/逻辑链路控制/3530198)（logic link control，LLC）子层和介质访问控制（media access control，MAC）子层。

### 第1层 物理层

主条目：[物理层](https://baike.baidu.com/item/物理层)

物理层（Physical Layer）在局部局域网上传送[数据帧](https://baike.baidu.com/item/数据帧)（data frame），它负责管理计算机通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、[主机适配器](https://baike.baidu.com/item/主机适配器/7362473)等。

## 扩展:TCP/IP协议知识

### 介绍

> TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是[TCP](https://baike.baidu.com/item/TCP/33012) 和[IP](https://baike.baidu.com/item/IP/224599)两个协议，而是指一个由[FTP](https://baike.baidu.com/item/FTP/13839)、[SMTP](https://baike.baidu.com/item/SMTP/175887)、TCP、[UDP](https://baike.baidu.com/item/UDP/571511)、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。 

### 概念

> TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。TCP/IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，TCP/IP传输协议是保证网络数据信息及时、完整传输的两个重要的协议。TCP/IP传输协议是严格来说是一个四层的体系结构，应用层、传输层、网络层和数据链路层都包含其中。 [2] 
>
> TCP/IP协议是Internet最基本的协议,其中应用层的主要协议有[Telnet](https://baike.baidu.com/item/Telnet/810597)、[FTP](https://baike.baidu.com/item/FTP/13839)、[SMTP](https://baike.baidu.com/item/SMTP/175887)等，是用来接收来自传输层的数据或者按不同应用要求与方式将数据传输至传输层；传输层的主要协议有[UDP](https://baike.baidu.com/item/UDP/571511)、TCP，是使用者使用平台和计算机信息网内部数据结合的通道，可以实现数据传输与数据共享；网络层的主要协议有ICMP、IP、IGMP，主要负责网络中数据包的传送等；而网络访问层，也叫网路接口层或数据链路层，主要协议有ARP、[RARP](https://baike.baidu.com/item/RARP/610685)，主要功能是提供链路管理错误检测、对不同通信媒介有关信息细节问题进行有效处理等。

### 优点

TCP/IP协议能够迅速发展起来并成为事实上的标准，是它恰好适应了世界范围内数据通信的需要。它有以下特点：

> （1）协议标准是完全开放的，可以供用户免费使用，并且独立于特定的[计算机硬件](https://baike.baidu.com/item/计算机硬件/5459592)与[操作系统](https://baike.baidu.com/item/操作系统/192)。
>
> （2）独立于网络硬件系统，可以运行在[广域网](https://baike.baidu.com/item/广域网/422004)，更适合于[互联网](https://baike.baidu.com/item/互联网/199186)。
>
> （3）网络地址统一分配，网络中每一设备和终端都具有一个唯一地址。
>
> （4）高层协议标准化，可以提供多种多样可靠网络服务。

### 缺点

像OSl模型一样，TCP/IP模型和协议也有自己的问题。

> （1）该模型没有明显地区分服务、接口和协议的概念。因此，对于使用新技术来设计新网络，TCP/IP模型不是一个太好的模板。 [5] 
>
> （2）TCP/IP模型完全不是通用的，并且不适合描述除TCP/IP模型之外的任何[协议栈](https://baike.baidu.com/item/协议栈/3155224)。 [5] 
>
> （3）链路层并不是通常意义上的一层。它是一个接口，处于网络层和数据链路层之间。接口和层间的区别是很重要的。 [5] 
>
> （4）TCP/IP模型不区分物理层和数据链路层。这两层完全不同，物理层必须处理铜缆、光纤和无线通信的传输特征；而数据链路层的工作是确定帧的开始和结束，并且按照所需的可靠程度把帧从一端发送到另一端。

### 通信过程及相关协议

> ### 大体流程
>
> 在[网络通信](https://baike.baidu.com/item/网络通信/9636548)的过程中，将发出数据的主机称为源主机，接收数据的主机称为目的主机。当源主机发出数据时，数据在源主机中从上层向下层传送。源主机中的应用进程先将数据交给应用层，应用层加上必要的控制信息就成了报文流，向下传给传输层。传输层将收到的数据单元加上本层的控制信息，形成报文段、数据报，再交给网际层。网际层加上本层的控制信息，形成IP数据报，传给网络接口层。网络接口层将网际层交下来的IP数据报组装成帧，并以比特流的形式传给网络硬件（即物理层），数据就离开源主机。
>
> ### 链路层
>
> > 以太网协议规定，接入网络的设备都必须安装网络适配器，即[网卡](https://baike.baidu.com/item/网卡/155684)，数据包必须是从一块网卡传送到另一块网卡。而网卡地址就是数据包的发送地址和接收地址，有了MAC地址以后，[以太网](https://baike.baidu.com/item/以太网/99684)采用广播形式，把数据包发给该子网内所有主机，子网内每台主机在接收到这个包以后，都会读取首部里的目标MAC地址，然后和自己的MAC地址进行对比，如果相同就做下一步处理，如果不同，就丢弃这个包。 [4] 
> >
> > 所以链路层的主要工作就是对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。 [4] 
>
> ### 网络层
>
> > **IP协议**
> >
> > 网络层引入了IP协议，制定了一套新地址，使得我们能够区分两台主机是否同属一个网络，这套地址就是网络地址，也就是所谓的IP地址。IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。如果两个IP地址在同一个子网内，则网络地址一定相同。为了判断IP地址中的网络地址，IP协议还引入了子网掩码，IP地址和子网掩码通过按位与运算后就可以得到网络地址。 [4] 
> >
> > **ARP协议**
> >
> > 即地址解析协议，是根据IP地址获取MAC地址的一个网络层协议。其工作原理如下：ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。 [4] 
> >
> > **路由协议**
> >
> > 首先通过IP协议来判断两台主机是否在同一个[子网](https://baike.baidu.com/item/子网/1186929)中，如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据包；如果不在同一个子网，以太网会将该数据包转发给本子网的网关进行路由。[网关](https://baike.baidu.com/item/网关/98992)是[互联网](https://baike.baidu.com/item/互联网/199186)上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给接收方。而完成这个路由协议的物理设备就是[路由器](https://baike.baidu.com/item/路由器/108294)，路由器扮演着交通枢纽的角色，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。 [4] 
> >
> > 所以，网络层的主要工作是定义网络地址、区分网段、子网内MAC寻址、对于不同子网的数据包进行路由。 [4] 
>
> ### 传输层
>
> > 链路层定义了主机的身份，即MAC地址，而网络层定义了IP地址，明确了主机所在的[网段](https://baike.baidu.com/item/网段/11026985)，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。而每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包。因此传输层引入了[UDP](https://baike.baidu.com/item/UDP/571511)协议来解决这个问题，为了给每个应用程序标识身份。
> >
> > **UDP协议**
> >
> > UDP协议定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。UDP协议比较简单，实现容易，但它没有确认机制，数据包一旦发出，无法知道对方是否收到，因此可靠性较差，为了解决这个问题，提高网络可靠性，TCP协议就诞生了。
> >
> > **TCP协议**
> >
> > TCP即传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议。简单来说TCP就是有确认机制的UDP协议，每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。为了保证传输的可靠性，TCP协议在UDP基础之上建立了三次对话的确认机制，即在正式收发数据前，必须和对方建立可靠的连接。TCP数据包和UDP一样，都是由首部和数据两部分组成，唯一不同的是，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 [4] 
> >
> > 传输层的主要工作是定义[端口](https://baike.baidu.com/item/端口/103505)，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性。 [4] 
>
> ### 应用层
>
> > 理论上讲，有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流，不能很好的被程序识别，操作性差，因此，应用层定义了各种各样的协议来规范数据格式，常见的有[http](https://baike.baidu.com/item/http/243074),ftp,[smtp](https://baike.baidu.com/item/smtp/175887)等，在请求[Header](https://baike.baidu.com/item/Header/688992)中，分别定义了请求数据格式Accept和响应数据格式Content-Type，有了这个规范以后，当对方接收到请求以后就知道该用什么格式来解析，然后对请求进行处理，最后按照请求方要求的格式将数据返回，请求端接收到响应后，就按照规定的格式进行解读。 [4] 
> >
> > 所以应用层的主要工作就是定义数据格式并按照对应的格式解读数据。 

##  扩展TCP可靠传输的原理

### 、为什么TCP是可靠传输？

#### 　　1. 停止等待协议

- - 通过确认与超时重传机制实现可靠传输
  - 在发送完一个分组后，必须暂时保留已发送的分组的副本。
  - 分组和确认分组都必须进行编号。
  - 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。

![img](F:/Typora/1639079-20190326083658281-1497754404-1625916376463.png)

　　出现差错或丢失的时候，发送方会将自己备份的副本再重传一次，直到收到接收的确认信息。当接收方收到重复的数据时，会直接丢弃，但是会给发送方请确认自己已经收到了。

　　![img](F:/Typora/1639079-20190326084430308-834201538.png)

#### 2. 改进的停止等待协议——连续ARQ协议和滑动窗口协议

　　上面的停止等待协议每发送一组数据就必须等到接收方回复确认后，再发起第二组数据，如果出现超时重传的话，效率更低。因此为了提高传输的效率，改进了等待传输协议。

　　连续ARQ协议和滑动窗口协议的机制是以接收方回复确认为单位，每次连续发送一个滑动窗口指定的数据组。示例图如下：

![img](F:/Typora/1639079-20190326085242097-1530796459.png)

##### 2.1 什么是滑动窗口协议？（发送方怎么发送数据）

　　滑动窗口是由发送方维护的类似指针的变量，在每收到一个接收方的确认消息后，该指针向前移动并发送数据，到窗口指定大小的数据组时停下，等待接收方的确认。示意看图：

　　![img](F:/Typora/1639079-20190326085809387-1572290065.png)

##### 　　2.2 接收方怎么回复确认？

###### 　　　累积确认机制

　　发送方不对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。

　　**优点**：容易实现，即使确认丢失也不必重传。

　　**缺点**：不能向发送方反映出接收方已经正确收到的所有分组的信息。

　　![img](F:/Typora/1639079-20190326090305031-1418988420.png)

###### Go-back-N（回退 N）

为了解决上述同一窗口中数据组不能完整确认的问题，连续ARQ协议采用了回退机制。比如说：发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。

结论：当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。可能还不如传统的停止等待协议。

#### 3. TCP可靠传输的实现

- TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。
- TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。
- TCP 两端的四个窗口经常处于动态变化之中。
- TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。

##### 3.1 以字节为单位的滑动窗口技术

　　滑动窗口是面向字节流的，为了方便记住每个分组的序号，下面的图解以一个分组假设100个字节，为了方便画图表示，将分组进行编号简化表示，如图所示，但是要记住，每一个分组的序号是多少。

　　![img](F:/Typora/1639079-20190326092218034-1593583323.png)

##### 3.2 改进的确认——选择确认(SACK)

　　TCP通信时，如果发送序列中间某个数据包丢失，TCP会通过重传最后确认的分组后续的分组，这样原先已经正确传输的分组也可能重复发送，降低了TCP性能。SACK（Selective Acknowledgment，选择确认）技术，使TCP只**重新发送丢失的包，不用发送后续所有的分组**，而且提供相应机制使接收方能告诉发送方哪些数据丢失，哪些数据已经提前收到等。在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的**不连续的字节块的边界**。

　　选择性确认最多表示4个边界：由于首部选项的长度最多只有 40 字节。需要一个字节指明是SACK选项，另一个字节指明占多少字节。而指明一个边界就要用掉 4 字节。在选项中最多只能指明 4 个字节块的边界信息。因4个字节块共8个边界信息。

　　![img](F:/Typora/1639079-20190326093322322-1964896573.png)

抓包分析：

![img](F:/Typora/1639079-20190326093502053-2033339768.png)

##### 3.3 超时重传时间的选择 

　　重传机制是 TCP 中最重要和最复杂的问题之一。TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。那么这个重传时间到底应该设置多少呢？这里面有学问。以下是我截取的“手抄报”，暂时看不懂。建议跳过。

###### 加权平均往返时间

　　TCP 保留了 RTT 的一个加权平均往返时间 RTTS（这又称为平滑的往返时间）。第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：

![img](F:/Typora/1639079-20190326094456258-364813112.png)

###### 超时计时器设置的超时重传时间RTO

![img](F:/Typora/1639079-20190326094700353-1883099673.png)

###### 往返时间的测量

![img](F:/Typora/1639079-20190326094805569-1318221961.png)

###### Karn算法

![img](F:/Typora/1639079-20190326094919513-707225845.png)

### 二、TCP的流量控制

　　流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 

　　流量控制举例说明：

　　![img](F:/Typora/1639079-20190326095720142-1021343698.png)

###### 零窗口处理——持续计数器

　　考虑上面的例子中，当A发送的数据已经到达B的接收窗口上限，此时A就必须等待B处理了部分数据后，待接收窗口有空闲的时候，再次发送数据，那么A是怎么知道B的接收窗口何时有空闲呢?这时就用到了持续计时器。

　　TCP 为每一个连接设有一个持续计时器。只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。若窗口不是零，则死锁的僵局就可以打破了。

### 三、TCP的传输效率

　　关于TCP的传输效率问题，需要从三方面来考虑，1.何时发送；2.少字节发送数据问题；3.糊涂窗口综合症问题

**3.1 TCP报文的发送时机：**

　　第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。
　　第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送(push)操作。
　　第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。

**3.2 少量字节发送数据问题：**

　　**问题描述**：如果应用程序一次产生一字节数据，这样会导致网络由于太多的包而过载。如：从键盘输入的一个字符，占用一个字节，可能在传输上造成41字节的包，其中包括1字节的有用信息和40字节的标题数据。

　　**解决方案（NAGLE算法）**：发送端的应用进程将欲发送的数据逐个字节地送到TCP缓存，则发送端就将第一个字符先发送出去。将后面到达的字符都缓存起来。当接收端收到对第一个字符确认后，再将缓存中的所有字符装成一个报文段发送出去，同时继续对随后到在的字符进行缓存。只有在收到对前一个报文段确认后才继续发送下一个报文段。

　**3.3 糊涂窗口综合症问题：


**

　　**问题描述：**设想一种情况：接收端缓存已满，而交互式的应用进程一次只从缓存中读取一个字符，然后向发送端发送确认，并将窗口设置1个字节。接着发送端又发来1个字符。接收端发回确认，仍然将窗口设置为1个字节。这样下去，网络效率非常低。

　　**解决方案：**接收端等待一段时间，使得缓存已有足够空间容纳；或者缓存已有一半空的空间，再向发送端发送确认**。**

## 扩展IP包头和TCP包头

### IP包头结构分析 



![img](F:/Typora/1343683-20190429153659171-1087132207.png)

**版本号（Version）：**长度4比特。标识目前采用的IP协议的版本号。一般的值为0100（IPv4），0110（IPv6）

**IP包头长度（Header Length）：**长度4比特。这个字段的作用是为了描述IP包头的长度，因为在IP包头中有变长的可选部分。该部分占4个bit位，单位为32bit（4个字节），即本区域值= IP头部长度（单位为bit）/(8*4)，因此，一个IP包头的长度最长为“1111”，即15*4＝60个字节。IP包头最小长度为20字节。

**服务类型（Type of Service）：**长度8比特。8位 按位被如下定义 PPP DTRC0

PPP：定义包的优先级，取值越大数据越重要

  000 普通 (Routine)

  001 优先的 (Priority)

  010 立即的发送 (Immediate)

  011 闪电式的 (Flash)

  100 比闪电还闪电式的 (Flash Override)

  101 CRI/TIC/ECP(找不到这个词的翻译)

  110 网间控制 (Internetwork Control)

  111 网络控制 (Network Control)

D 时延: 0:普通 1:延迟尽量小

T 吞吐量: 0:普通 1:流量尽量大

R 可靠性: 0:普通 1:可靠性尽量大

M 传输成本: 0:普通 1:成本尽量小

0 最后一位被保留，恒定为0

**IP包总长（Total Length）：**长度16比特。 以字节为单位计算的IP包的长度 (包括头部和数据)，所以IP包最大长度65535字节。

**标识符（Identifier）:**长度16比特。该字段和Flags和Fragment Offest字段联合使用，对较大的上层数据包进行分段（fragment）操作。路由器将一个包拆分后，所有拆分开的小包被标记相同的值，以便目的端设备能够区分哪个包属于被拆分开的包的一部分。

**标记（Flags）：**长度3比特。该字段第一位不使用。第二位是DF（Don't Fragment）位，DF位设为1时表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发，则路由器会丢弃该上层数据包并返回一个错误信息。第三位是MF（More Fragments）位，当路由器对一个上层数据包分段，则路由器会在除了最后一个分段的IP包的包头中将MF位设为1。

**片偏移（Fragment Offset）：**长度13比特。表示该IP包在该组分片包中位置，接收端靠此来组装还原IP包。

**生存时间（TTL）：**长度8比特。当IP包进行传送时，先会对该字段赋予某个特定的值。当IP包经过每一个沿途的路由器的时候，每个沿途的路由器会将IP包的TTL值减少1。如果TTL减少为0，则该IP包会被丢弃。这个字段可以防止由于路由环路而导致IP包在网络中不停被转发。 

**协议（Protocol）：**长度8比特。标识了上层所使用的协议。

以下是比较常用的协议号：

  1  ICMP

  2  IGMP

  6  TCP

  17  UDP

  88  IGRP

  89  OSPF

**头部校验（Header Checksum）：**长度16位。用来做IP头部的正确性检测，但不包含数据部分。 因为每个路由器要改变TTL的值,所以路由器会为每个通过的数据包重新计算这个值。

**起源和目标地址（Source and Destination Addresses）：**这两个地段都是32比特。标识了这个IP包的起源和目标地址。要注意除非使用NAT，否则整个传输的过程中，这两个地址不会改变。

至此，IP包头基本的20字节已介绍完毕，此后部分属于可选项，不是必须的部分。

**可选项（Options）：**这是一个可变长的字段。该字段属于可选项，主要用于测试，由起源设备根据需要改写。可选项目包含以下内容：

  松散源路由（Loose source routing）：给出一连串路由器接口的IP地址。IP包必须沿着这些IP地址传送，但是允许在相继的两个IP地址之间跳过多个路由器。

  严格源路由（Strict source routing）：给出一连串路由器接口的IP地址。IP包必须沿着这些IP地址传送，如果下一跳不在IP地址表中则表示发生错误。

  路由记录（Record route）：当IP包离开每个路由器的时候记录路由器的出站接口的IP地址。

  时间戳（Timestamps）：当IP包离开每个路由器的时候记录时间。

**填充（Padding）：**因为IP包头长度（Header Length）部分的单位为32bit，所以IP包头的长度必须为32bit的整数倍。因此，在可选项后面，IP协议会填充若干个0，以达到32bit的整数倍。

### TCP头部结构详解



 

tcp头部信息出现在每个tcp报文段中，用于指定通信的源端端口，目的端口，管理tcp连接等。tcp头部结构如下图所示:


![img](F:/Typora/e84fe75431647f9db903cbd3d04a71fc.JPEG)tcp头部结构

**1、16位端口号：**告知主机该报文段来自哪里（源端口）以及传给哪个上层协议或应用程序（目的端口）的。进行tcp通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。

**2、32位序号：**一次tcp通信过程中某一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行tcp通信，A发送给B的第一个tcp报文段中，序号值被系统初始化为某个随机值ISN。那么在该传输方向上（从A到B），后续的tcp报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个在整个字节流中的偏移。例如，某个tcp报文段传送的数据时字节流中的第1025~2048字节，那么该报文段的序号值就是ISN+1025。另一个传输方向（从B到A）的tcp报文段的序号值也具有相同的含义。

**3、32位确认号：**用作对另一方发送来的tcp报文段的相应。其值是收到的tcp报文段的序号值加1。假设主机A和主机B进行tcp通信，那么A发送出的tcp报文段不仅携带自己的序号，而且包含对B发送来的tcp报文段的确认号。反之，B发送出的tcp报文段也同时携带自己的序号和对A发送来的报文的确认号。

**4、4位头部长度：**标识该tcp头部有多少个32bit字（4字节）因为4位最大能表示15，所以tcp头部最长是60字节。

**5、6位标志位（即图中的保留6位）：**标志位有如下几项

- URG标志，表示紧急指针是否有效
- ACK标志，表示确认号是否有效。称携带ACK标志的tcp报文段位确认报文段
- PSH标志，提示接收端应用程序应该立即从tcp接受缓冲区中读走数据，为接受后续数据腾出空间（如果应用程序不将接收的数据读走，它们就会一直停留在tcp缓冲区中）
- RST标志，表示要求对方重新建立连接。携带RST标志的tcp报文段为复位报文段。
- SYN标志，表示请求建立一个连接。携带SYN标志的tcp报文段为同步报文段。
- FIN标志，表示通知对方本端要关闭连接了。携带FIN标志的tcp报文段为结束报文段。

**6、16位窗口大小：**是tcp流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的tcp接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。

**7、16位校验和：**由发送端填充，接收端对tcp报文段执行CRC算法以校验tcp报文段在传输过程中是否损坏。注意，这个校验不仅包括tcp头部，也包括数据部分。这也是tcp可靠传输的一个重要保障。

**8、16位紧急指针：**是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，确切的说，这个字段是紧急指针相对当前***的偏移，称为紧急偏移。tcp的紧急指针是发送端向接收端发送紧急数据的方法。

**9、16位选项：**

​    TCP头部的最后一个选项字段是可变长的可选信息。这部分最多包含40字节，因为TCP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。典型的TCP头部选项结构如图3-4所示。

​    选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段info（如果有的话）是选项的具体信息。常见的TCP选项有7种，如图3-5所示。

​    kind=0是选项表结束选项。
​    kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。
​    kind=2是最大报文段长度选项。TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。
​    kind=3是窗口扩大因子选项。TCP连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在TCP的头部中，接收通告窗口大小是用16位表示的，故最大为65?535字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数（为了提高TCP通信的吞吐量）。窗口扩大因子解决了这个问题。假设TCP头部中的接收通告窗口大小是N，窗口扩大因子（移位数）是M，那么TCP报文段的实际接收通告窗口大小是N乘2M，或者说N左移M位。注意，M的取值范围是0～14。我们可以通过修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或关闭窗口扩大因子选项。
和MSS选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档RFC 1323。
​    kind=4是选择性确认（Selective Acknowledgment，SACK）选项。TCP通信时，如果某个TCP报文段丢失，则TCP模块会重传最后被确认的TCP报文段后续的所有报文段，这样原先已经正确传输的TCP报文段也可能重复发送，从而降低了TCP性能。SACK技术正是为改善这种情况而产生的，它使TCP模块只重新发送丢失的TCP报文段，不用发送所有未被确认的TCP报文段。选择性确认选项用在连接初始化时，表示是否支持SACK技术。我们可以通过修改/proc/sys/net/ipv4/tcp_sack内核变量来启用或关闭选择性确认选项。
​    kind=5是SACK实际工作的选项。该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个4字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用8字节，所以TCP头部选项中实际上最多可以包含4个这样的不连续数据块（考虑选项类型和长度占用的2字节）。
​    kind=8是时间戳选项。该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为TCP流量控制提供重要信息。我们可以通过修改/proc/sys/net/ipv4/tcp_timestamps内核变量来启用或关闭时间戳选项。

